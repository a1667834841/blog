---
title: 2022-05-24_note
date: 2022-11-13 23:10:11
permalink: /pages/1ea5df/
categories:
  - 每日随笔
  - 2022-05
tags:
  - 
---
**mood:** :smile:  									**date: 2022-05-24**  
## 今日计划  
------
- [ ]  工厂模式
- [ ]  15个单词
## 明日计划  
------
- [ ]  
## 随写 
------

问题：

- 工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如 Java 中的 Calendar、DateFormat 类。除此之外，你还知道哪些用工厂模式实现类？可以留言说一说它们为什么要设计成工厂模式类？

  > 像mybatis的`SqlSessionFactory`，spring的`BeanFactory`都使用了工厂模式，就拿`SqlSessionFactory`的一个实现`DefaultSqlSessionFactory`来说,它里面的创建sqlSession还是比较复杂的。
  >
  > ```java
  >   private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  >     Transaction tx = null;
  >     try {
  >         // 获取环境（数据库连接池，事务工厂）
  >       final Environment environment = configuration.getEnvironment();
  >       final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
  >       tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
  >         // 获取执行器
  >       final Executor executor = configuration.newExecutor(tx, execType);
  >         // 配置信息，执行器，是否自动提交 来创建sqlSessuin
  >       return new DefaultSqlSession(configuration, executor, autoCommit);
  >     } catch (Exception e) {
  >       closeTransaction(tx); // may have fetched a connection so lets call close()
  >       throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
  >     } finally {
  >       ErrorContext.instance().reset();
  >     }
  >   }
  > ```
  >
  > 如果这个让开发者自己用的时候写，这样会导致代码重复，后期如果修改也麻烦，所以我认为这里是封装成工厂类，为了减少代码冗余，封装创建过程，使用者也能更方便的创建sqlSession。
  >
  > 

- 实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？

  > 为什么设计成静态，不清楚，我个人认为只是将创建对象的时机改变了而已，
  >
  > 不影响代码的可测试性，因为他的指责并没有改变，只是单纯的创建对象而已



工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。

1. 简单工厂：利用简单的if-else,switch等语句，创建对应的对象。

   ​	适用：对象的类型少，以后修改的代码少

2. 工厂方法：定义一个创建对象的接口，将简单工厂内创建对象的过程，封装到接口实现类中，尽量避免修改，多扩展，利用多态和创建工厂的工厂可以避免if等判断语句。

   ​	适用：创建的对象类型多，创建对象的过程复杂（如果创建对象过程简单使用简单工厂更好）这样后期需要做很多改动，多一个对象类型，只需要多创建一个工厂类就好，而不需要修改主要的流程。

3. 抽象工厂：抽象工厂可以让一个工厂负责创建多个不同类型的对象。（提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类--来自《Head First》）

作用：（一句话 封装创建对象过程，使用者不需要关心内部实现）

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
- 代码复用：创建代码抽离到独立的工厂类之后可以复用。
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

```java
public interface IRuleConfigParserFactory {
  IRuleConfigParser createParser();
}

public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new JsonRuleConfigParser();
  }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new XmlRuleConfigParser();
  }
}

public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new YamlRuleConfigParser();
  }
}

public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new PropertiesRuleConfigParser();
  }
}

// 第一版
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);

    IRuleConfigParserFactory parserFactory = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new JsonRuleConfigParserFactory();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new XmlRuleConfigParserFactory();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new YamlRuleConfigParserFactory();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new PropertiesRuleConfigParserFactory();
    } else {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

// 第二版
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);

    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();

  static {
    cachedFactories.put("json", new JsonRuleConfigParserFactory());
    cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());
  }

  public static IRuleConfigParserFactory getParserFactory(String type) {
    if (type == null || type.isEmpty()) {
      return null;
    }
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
    return parserFactory;
  }
}






```

