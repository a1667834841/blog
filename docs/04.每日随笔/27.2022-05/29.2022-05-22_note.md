---
title: 2022-05-22_note
date: 2022-11-13 23:10:11
permalink: /pages/6626f0/
categories:
  - 每日随笔
  - 2022-05
tags:
  - 
---
**mood:** :smile:  									**date: 2022-05-22**  
## 今日计划  
------
- [ ]  
- [ ]  15个单词
## 明日计划  
------
- [ ]  
## 随写 
------

问题

1. 在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？

>  java的sun.misc.Unsafe类，还是采用饿汉式的，因为这个类不是所有类加载器都能加载的
>
> 在`getUnsafe()`，会判断调用方的类加载器，只有最顶层的bootrap加载器才能加载，像app加载器，也就是我们平常创建的类是不能加载的，unsafe提供能了改变内存的操作，所以权限控制的很紧。

2. 在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？

> 一个线程写一个日志文件，最后汇总

## 单例模式概念

> 单例设计模式（SingletonDesignPattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。

##可以解决什么问题？

### 往文件中打印日志的Logger类（多个线程操作共享变量造成的并发问题）

通常解决办法：

1. 加`synchronized`关键字，不允许多个线程同时操作同一个共享变量
2. 加分布式锁（复杂）
3. 创建工作队列，串行执行操作（复杂）

作者给出办法，利用单例模式，创建类的唯一的实例，所有线程共享同一个logger对象，FileWriter本身是对象级别线程安全的，所以保证同一时间只能被一个线程写入文件

### 创建唯一id

特别是在微服务中，多个微服务可能都会使用到创建id的功能，id需要保证唯一性，如果程序中有两个对象，那就会存在生成重复ID的情况，所以，我们应该将ID生成器类设计为单例。



创建单例模式的方式

需要关注的点

- 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
- 考虑对象创建时的线程安全问题；
- 考虑是否支持延迟加载；
- 考虑 getInstance() 性能是否高（是否加锁）。

**饿汉式**

缺点：会影响程序启动时间

优点：没有性能问题

**懒汉式**

优点：支持延迟加载

缺点：有性能问题

**双重检测**

支持延迟加载，且没有性能问题

需要注意：

```java
public class Single {

	private static Single single;
	
	private Single() {
	}
	
	public static Single getInstance() {
		if(null == single) {
			synchronized (Single.class) {
				if(null == single) {
					single = new Single();
				}
			}
		}
		return single;
	}
}
```



其实single = new Single()这段代码并不具备原子性，从代码层面上来说确实没问题，但是如果了解JVM指令的就知道其实在执行这句代码的时候在JVM中是需要执行三个指令来完成的，如下：

`memory = allocate(); //1：分配对象的内存空间`
`ctorInstance(memory); //2：初始化对象`
`instance = memory; //3：设置instance指向刚分配的内存地址`
看到上面指令重排的解释之后，那么我们来回顾一下未加volatile修饰符的单例为何会出现问题。
假设有A、B两个线程去调用该单例方法，当A线程执行到single = new Single()时，如果编译器和处理器对指令重新排序，指令重排后：

`memory = allocate(); //1：分配对象的内存空间`
`instance = memory; //3：设置instance指向刚分配的内存地址，此时对象还没被初始化`
`ctorInstance(memory); //2：初始化对象`
当A线程执行到第二步（3：设置instance指向刚分配的内存地址，此时对象还没被初始化）变量single指向内存地址之后就不为null了，此时B线程进入第一个if，由于single已经不为null了，那么就不会执行到同步代码块，而是直接返回未初始化对象的变量single，从而导致后续代码报错。



**静态内部类**

利用Java的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。

**枚举**

最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。