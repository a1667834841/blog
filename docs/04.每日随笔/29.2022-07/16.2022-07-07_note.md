---
title: 2022-07-07_note
date: 2022-11-13 23:10:12
permalink: /pages/eb2987/
categories:
  - 每日随笔
  - 2022-07
tags:
  - 
---
**mood:** :smile:  									**date: 2022-07-07**  
## 今日计划  
------
- [ ]  并发编程
- [ ]  15个单词
## 明日计划  
------
- [ ]  
## 随写 
------

1. 局部变量为什么不会造成并发问题？

   1. 理解方法的调用过程

   2. 局部变量和方法和线程的关系？

      局部变量是存在栈帧里面，方法调用会创建栈帧（栈帧是方法调用背后的支撑），线程调用方法的入参，局部变量，方法返回地址都是存在栈帧，线程都拥有自己的栈帧

![图片](https://static001.geekbang.org/resource/image/ec/9c/ece8c32d23e4777c370f594c97762a9c.png)

![图片](https://static001.geekbang.org/resource/image/84/1a/840cb955e521bd51776dbcdad3dba11a.png)

栈溢出原因：
因为每调用一个方法就会在栈上创建一个栈帧，方法调用结束后就会弹出该栈帧，而栈的大小不是无限的，所以递归调用次数过多的话就会导致栈溢出。而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件。所以递归调用一定要明确好结束条件，不要出现死循环，而且要避免栈太深。
解决方法：
1. 简单粗暴，不要使用递归，使用循环替代。缺点：代码逻辑不够清晰；
2. 限制递归次数；
3. 使用尾递归，尾递归是指在方法返回时只调用自己本身，且不能包含表达式。编译器或解释器会把尾递归做优化，使递归方法不论调用多少次，都只占用一个栈帧，所以不会出现栈溢出。然鹅，Java没有尾递归优化。

> 
>
> 首先，解答什么是[尾递归](https://www.zhihu.com/search?q=尾递归&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1094636184})。
>
> 简单来讲，尾递归是指在一个方法内部，递归调用后直接return，没有任何多余的指令了。
>
> **个人理解：利用入参将需要环境参数传入方法，这样调用方法就不需要上一次方法调用的环境了，上一次调用方法的栈帧也就无需保留。**
>
> 比如，一个递归实现的[累加函数](https://www.zhihu.com/search?q=累加函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1094636184})
>
> ```java
>     public static int acc(int n){
>         if(n == 1){
>             return 1;
>         }
>         return n + acc(n - 1);
>     }
> ```
>
> 请问这个是尾递归么？答案是否定的。
>
> 可能有的人会说，明明最后一个步骤就是调用acc，为啥不是尾递归？
>
> 实际上，你看到的最后一个步骤不代表从指令层面来讲的最后一步。这个方法的return先拿到acc(n-1)的值，然后再将n与其相加，所以求acc(n-1)并不是最后一步，因为最后还有一个add操作。
>
> 把上面的代码做个[等价逻辑](https://www.zhihu.com/search?q=等价逻辑&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1094636184})转换就很清晰了。
>
> ```java
>     public static int acc(int n){
>         if(n == 1){
>             return 1;
>         }
>         int r = acc(n - 1);
>         return n + r;
>     }
> ```
>
> 看，是不是还隐含一个add操作？
>
> 累加的尾递归写法是下面这样子的：
>
> ```java
>     public static int accTail(int n, int sum){
>         if(n == 1){
>             return sum + n;
>         }
>         return accTail(n - 1,sum + n);
>     }
> ```
>
> 递归调用后就直接返回了，这是真正的尾递归。
>
> 作者：贾贾贾
> 链接：https://www.zhihu.com/question/20761771/answer/1094636184
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。







final 

修饰类：类不能被继承

修饰方法：方法不能被重写

修饰变量：如果变量是基本类型，值不能被改变；如果变量是引用类型，在初始化之后不能再指向另一个对象



lock 与 lockInterruptibly比较区别在于：
lock 优先考虑获取锁，待获取锁成功后，才响应[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)。
lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取。



```
docker run
```

