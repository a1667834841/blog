---
title: 2022-07-16_note
date: 2022-11-13 23:10:12
permalink: /pages/e7b140/
categories:
  - 每日随笔
  - 2022-07
tags:
  - 
---
**mood:** :smile:  									**date: 2022-07-16**  
## 今日计划  
------
- [ ]  结算单生成 后期添加保存异常操作
- [x]  售后单 生成，订单查商品 
- [x]  自动开发票需要测试，多张正向单和多张逆向单场景
- [x]  发票推送 修改
- [ ]  售后单推erp 需要测试
- [x]  结算单发票列表查询，导出 测试
- [x]  结算单开票模板下载
- [x]  结算单导入接口
- [ ]  15个单词
## 明日计划  
------
- [ ]  售后单推erp 需要测试
- [ ]  结算单生成 后期添加保存异常操作
## 随写 
------

```
sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.3.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
```

```
## 注意的点
1. **不建议使用 Executors** 的最重要的原因是：Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue，高负载情境下，无界队列很容易导致 OOM，而 OOM 会导致所有请求都无法处理，这是致命问题。所以强烈建议使用有界队列。
2. **默认拒绝策略要慎重使用。** 如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。

## 线程池 添加任务流程
一开始线程池初始化`核心线程数`的线程数量，之后任务被添加到队列中，线程去消费队列中的任务，
如果队列被塞满，需要看当前线程数是否大于最大线程数，如果没有，则创建新的线程去消费任务，
如果队列被塞满，需要创建工作线程，此时会判断工作线程数是否大于等于最大线程数，则开始执行拒绝策略

​```java
 public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) { // 工作线程小于核心线程
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) { // 队列未满，仍然可以插入任务
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false)) // 队列已满，添加工作线程失败
            reject(command);
    }
​```

​```java
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize)) // 判断工作线程数大于等于最大核心数，大于则返回false
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
​```

## 执行拒绝策略的时机？
（如果队列被塞满，需要创建工作线程，此时会判断工作线程数是否大于等于最大线程数，则开始执行拒绝策略）
工作线程数大于等于 最大线程数+队列长度，则开始执行拒绝策略

拒绝策略：
DiscardOldestPolicy  -- 丢弃队列中等待时间最久的，立马执行新添加进来的任务
AbortPolicy -- 直接丢弃，抛出异常（默认使用）
CallerRunsPolicy -- 直接在execute方法的调用线程中运行被拒绝的任务
DiscardPolicy -- 被拒绝任务的处理程序，它默默地丢弃被拒绝的任务（不抛出异常）

```

如何给线程池中的线程命名

1. 给线程池设置名称前缀

```java
ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
threadPoolTaskExecutor.setThreadNamePrefix("CUSTOM_NAME_PREFIX&#34");
```

1. 在ThreadFactory中自定义名称前缀

```java
class CustomThreadFactory implements ThreadFactory {
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(&#34;CUSTOM_NAME_PREFIX&#34;);
            return thread;
        }
    }

ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10,
                100,
                120,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(),
                new CustomThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
```