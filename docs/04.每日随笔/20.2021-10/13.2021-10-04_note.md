---
title: 2021-10-04_note
date: 2022-11-13 23:10:11
permalink: /pages/d98760/
categories:
  - 每日随笔
  - 2021-10
tags:
  - 
---
**mood:** :smile:  																		**date: 2021-10-04**  
## 今日计划  
------
- [ ]  事务失效测试
- [ ] easyExcel 合并单元格笔记
- [ ] 操作日志工具类
## 明日计划  
------
- [ ]  
## 随写 
------



PROPAGATION_REQUIRED

如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，这是最常见的选择，也是Spring默认的事务传播行为。



1. 一个service内，方法A和方法B事务隔离级别都是REQUIRED，insertAAndB方法无事务

```java
 	@Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertA() {
        User user = new User();
        user.setAge(1);
        user.setName("test");
        userDao.insert(user);
        // A方法抛异常
        int i = 1/0;
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void insertB() {
        TUser user = new TUser();
        user.setAge(1);
        user.setName("test");
        tUserDao.insert(user);
    }

    @Override
    public void insertAAndB() {
        insertA();
        insertB();
    }
    
------------------分界线---------------------
    
    @Test
    void insertAAndB() {
        // 一个service内 事务传播行为都是required 测试方法A有异常 方法A成功执行，方法B因为异常未执行
        transactionTestAService.insertAAndB();
    }
```

分析：方法A声明了事务，但是因为一个service内，方法 insertAAndB 调用了 方法A和方法B，属于自身调用，事务失效，所以方法A抛异常未回滚。

自身调用（spring的声明式事务，是利用代理类来实现的，方法A和方法B都有自己的代理方法，但是由于insertAAndB没有声明事务，所以走的是实际的方法，方法insertAAndB调用的是实际的方法A和方法B，所以事务失效）



一个service内 事务传播行为都是required 方法insertAAndB有异常 方法A 和 方法B 都不回滚

```java
 @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertA() {
        User user = new User();
        user.setAge(1);
        user.setName("test");
        userDao.insert(user);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void insertB() {
        TUser user = new TUser();
        user.setAge(1);
        user.setName("test");
        tUserDao.insert(user);
    }

    @Override
    public void insertAAndB() {
        insertA();
        insertB();
        // 非事务方法抛异常
        int i = 1/0;
    }
    
    @Test
    void insertAAndB() {
        // 一个service内 事务传播行为都是required 方法insertAAndB有异常 方法A 和 方法B 都不回滚
        transactionTestAService.insertAAndB();
    }
```

分析：外围方法未开启事务，方法A和方法B在自己的事务中进行，外围异常并未影响。



一个service内 事务传播行为都是required 方法insertAAndB也具有事务，传播行为为REQUIRED，且有异常 方法A 和 方法B都回滚

```java
 @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertA() {
        User user = new User();
        user.setAge(1);
        user.setName("test");
        userDao.insert(user);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void insertB() {
        TUser user = new TUser();
        user.setAge(1);
        user.setName("test");
        tUserDao.insert(user);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertAAndB() {
        insertA();
        insertB();
        int i = 1/0;
    }
    
    @Test
    void insertAAndB() {
        // 一个service内 事务传播行为都是required 方法insertAAndB也具有事务，传播行为为REQUIRED，且有异常 方法A 和 方法B都回滚
        transactionTestAService.insertAAndB();
    }
```

分析：因为方法 insertAAndB具有事务，且事务隔离级别是REQUIRED（如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务）,三个方法处于同一事务中，所以有异常，就会回滚







# 事务失效的原因

1. ## 数据库引擎不支持事务

   （这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB）

2. ## 没有被 Spring 管理

3. ## 方法不是 public的 -- 该异常一般情况都会被编译器帮忙识别

   > When using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.

4. ## 自身调用问题

5. ## 数据源没有配置事务管理器

6. ## 不支持事务

```java
@Service
public class OrderServiceImpl implements OrderService {
    @Transactional
    public void update(Order order) {
        updateOrder(order);
    }
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void updateOrder(Order order) {
        // update order；
    }
}
```

7. ## 异常被吃了

8. ## 异常类型错误或格式配置错误





## 解决自身调用引起事务失效的办法

1. 把方法A()和方法B()分别放到不同的类里，使构成自身调用的条件失效
2. 自己注入自己，用注入的实例调用

```java
@Service
class TransactionTestAServiceImpl implements TransactionTestAService {

    @Resource
    TUserDao tUserDao;
    @Resource
    UserDao userDao;
    @Resource
    TransactionTestAService transactionTestAService;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertA() {
        User user = new User();
        user.setAge(1);
        user.setName("test");
        userDao.insert(user);
        int i = 1/0;
    }

    @Transactional(propagation = Propagation.REQUIRED)
    @Override
    public void insertB() {
        TUser user = new TUser();
        user.setAge(1);
        user.setName("test");
        tUserDao.insert(user);

    }

    @Override
//    @Transactional(propagation = Propagation.REQUIRED)
    public void insertAAndB() {
        transactionTestAService.insertA();
        transactionTestAService.insertB();
    }
}
```

3. 获取代理类，利用代理类调用自己类的方法

```java
@Service
class TransactionTestAServiceImpl implements TransactionTestAService {

    @Resource
    TUserDao tUserDao;
    @Resource
    UserDao userDao;
    @Resource
    TransactionTestAService transactionTestAService;

    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void insertA() {
        User user = new User();
        user.setAge(1);
        user.setName("test");
        userDao.insert(user);
        int i = 1/0;
    }

    @Transactional(propagation = Propagation.REQUIRED)
    @Override
    public void insertB() {
        TUser user = new TUser();
        user.setAge(1);
        user.setName("test");
        tUserDao.insert(user);

    }

    @Override
//    @Transactional(propagation = Propagation.REQUIRED)
    public void insertAAndB() {
//        transactionTestAService.insertA();
//        transactionTestAService.insertB();
        ((TransactionTestAService) AopContext.currentProxy()).insertA();
        ((TransactionTestAService) AopContext.currentProxy()).insertB();
    }
}
```

