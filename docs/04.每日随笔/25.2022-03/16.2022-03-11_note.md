---
title: 2022-03-11_note
date: 2022-11-13 23:10:11
permalink: /pages/89e92f/
categories:
  - 每日随笔
  - 2022-03
tags:
  - 
---
**mood:** :smile:  									**date: 2022-03-11**  

## 今日计划  
------
- [ ]  spring的BeanFacotry和ApplicationContext
- [ ] 微信账单自动记录
## 明日计划  
------
- [ ]  
## 随写 
------

```
docker run -p 7700:7700 -v "D:\docker\meilisearch\data.ms:/data.ms" getmeili/meilisearch

curl -X POST 'http://127.0.0.1:7700/indexes/movies/documents' -H 'Content-Type: application/json' --data-binary $movies.json

curl -X GET 'http://localhost:7700/indexes/movies/tasks/0'

```



ioc：控制反转，以前是需要什么`物品`自己主动去拿，现在是需要什么`物品`，叫另外一个人帮自己拿。**物品的控制权变了**

依赖注入的三种方式：

构造方法

set方法

接口注入（不常用）

![image-20220309141326670](https://img.ggball.top/picGo/image-20220309141326670.png)



Ioc service provider

职责：

1. 将依赖代码剥出
2. 对象绑定依赖对象

通过`Ioc service provider`注入依赖对象的方式：

1. 直接编码方式

程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系

2. 配置文件方式

3. 元数据方式

通过@Inject，我们指明需要IoC Service Provider通过构造方法注入方式





Spring提供了两种容器类型：BeanFactory和ApplicationContext。

BeanFacotory

基础类型IoC容器，提供完整的IoC服务支持,默认采用延迟加载策略，也就是需要用到被依赖对象时，才对该受管对象进行初始化以及依赖注入操作。

看接口方法的话，只是提供了获取Bean对象，Bean的一些属性的方法



## 直接编码方式

通过BeanFactory容器完成bean注册和依赖注入

1. 构造方法
2. setter方法



BeanDefinitionRegistry 担当Bean注册管理的角色，是一个接口，它定义了关于 BeanDefinition 的注册、移除、查询等一系列的操作。

## 外部配置文件方式

外部配置方式的话，就需要读取配置文件信息，`BeanDefinitionReader` 的作用读取配置文件，负责将相应的配置文件内容读取并映射到BeanDefinition

1. properties文件
2. xml文件

## 注解方式

注解（@Component，@Autowired...）配合`classpath-scanning`功能使用，这个相当于告诉容器需要扫描的包，明确一个范围。



## bean在xml文件配置，标签解析

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd">

<beans>

<!-- bean definitions here -->
    // target bean to be referenced by name
    <bean id="person" class="org.springframework.beans.TestBean" scope="prototype">
        <property name="age" value="10"/>
        <property name="spouse">
            <bean class="org.springframework.beans.TestBean">
                <property name="age" value="11"/>
            </bean>
        </property>
    </bean>

    // will result in 11, which is the value of property 'spouse.age' of bean 'person'
    <bean id="theAge"
            class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
        <property name="targetBeanName" value="person"/>
        <property name="propertyPath" value="spouse.age"/>
    </bean>
</beans>
```

### Beans

beans：是XML配置文件中最顶层的元素，它下面可以包含0或者1个<description>和多个<bean>以及<import>或者<alias>。

```dtd
<!ATTLIST beans default-lazy-init (true | false) "false">
其值可以指定为true或者false，默认值为false。用来标志是否对所有的<bean>进行延迟初始化

<!ATTLIST beans default-merge (true | false) "false">

<!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) "no">
可以取值为no、byName、byType、constructor以及autodetect。默认值为no，如果使用自动绑定的话，用来标志全体bean使用哪一种默认绑定方式。

<!ATTLIST beans default-init-method CDATA #IMPLIED>
如果所管辖的<bean>按照某种规则，都有同样名称的初始化方法的话，可以在这里统一指定这个初始化方法名，而不用在每一个<bean>上都重复单独指定。

<!ATTLIST beans default-destroy-method CDATA #IMPLIED>
与default-init-method相对应，如果所管辖的bean有按照某种规则使用了相同名称的对象销毁方法，可以通过这个属性统一指定。
```

description：可以通过<description>在配置的文件中指定一些描述性的信息。

import：在想加载主要配置文件，并将主要配置文件所依赖的配置文件同时加载时，可以在这个主要的配置文件中通过<import>元素对其所依赖的配置文件进行引用

alias：可以通过<alias>为某些<bean>起一些“外号”（别名），通常情况下是为了减少输入。

bean：所有注册到容器的业务对象，在Spring中称之为Bean。

#### bean

bean：所有注册到容器的业务对象，在Spring中称之为Bean。

- **id**：每个注册到容器的对象的唯一标志，就好像我们每一个人都有一个身份证号一样，有些情况下，id可以省略。

- **name**：指定<bean>的别名。**与id属性相比，name属性的灵活之处在于，name可以使用id不能使用的一些字符，比如/。**

- **class**：指定class文件路径，在大部分情况下，该属性是必须的。仅在少数情况下不需要指定。

- **depends-on**：某些时候，我们没有通过类似<ref>的元素明确指定对象A依赖于对象B的话，可以使用depend-on实例化对象，即不显性的指明依赖对象，实例化对象（例子：log4j,数据库驱动之类的）

- **autowire**：自动装配，xml配置不显性指定依赖对象，但是对象代码中还是要申明依赖对象，根据(no | byName | byType | constructor | autodetect)规则去容器查找对应对象。
  	
  - **no**：不采用自动装配。
  - **byName**：根据bean名称查找，装配对象，如果没有找到，则不做设置。
  - **byType**：根据bean的类型查找，装配对象，如果没有找到，则不做设置，如果找到多个，容器会告诉你它解决不了“该选用哪一个”的问题，你只好自己查找原因，并自己修正该问题。
  - **constructor**：constructor类型则是针对构造方法参数的类型而进行的自动绑定
  
- **autodetect**：这种模式是byType和constructor模式的结合体，如果对象拥有默认无参数的构造方法，容器会优先考虑byType的自动绑定模式
  
- **dependency-check**：我们可以使用每个<bean>的dependency-check属性对其所依赖的对象进行最终检查。
  	
  - **none**：不依赖检查。
  - **simple**：如果将dependency-check的值指定为simple，那么容器会对**简单属性类型**以及相关的**collection进行依赖检查**，**对象引用类型的依赖除外**。
  - **object**：只对对象引用类型依赖进行检查。
  - **all**：利用simple和object两种检查策略。
  
- **lazy-init**

   延迟初始化Bean，但要注意，如果A对象依赖了`lazy_bean`(设置了lazy_init=true的bean对象)，A对象仍然会初始化`lazy_bean`，没有延迟初始化Bean。

- **parent**

   子类继承父类所依赖的对象，子类就可以省略配置依赖对象
   
- **socpe**

   bean的作用域，spring2.0之前有singleton和prototype两种作用域，spring2.0之后有	

constructor-arg：如同声明一个构造方法，里面是需要填入的构造参数。

```dtd
<!ATTLIST constructor-arg index CDATA #IMPLIED>
指定构造参数的位置
<!ATTLIST constructor-arg type CDATA #IMPLIED>
指定构造参数的类型
<!ATTLIST constructor-arg ref CDATA #IMPLIED>
使用ref来引用容器中其他的对象实例
...
一共有bean、ref、idref、value、null、list、set、map、props
```

property：申明bean的属性对象

```dtd
<!ATTLIST constructor-arg index CDATA #IMPLIED>
指定构造参数的位置
<!ATTLIST constructor-arg type CDATA #IMPLIED>
指定构造参数的类型
<!ATTLIST constructor-arg ref CDATA #IMPLIED>
使用ref来引用容器中其他的对象实例
...
一共有bean、ref、idref、value、null、list、set、map、props
```

##### ref

使用ref来引用容器中其他的对象实例

```dtd
<!ATTLIST ref bean CDATA #IMPLIED>
bean则基本上通吃，所以，通常情况下，直接使用bean来指定对象引用就可以了。
<!ATTLIST ref local IDREF #IMPLIED>
local只能指定与当前配置的对象在同一个配置文件的对象定义的名称
<!ATTLIST ref parent CDATA #IMPLIED>
parent则只能指定位于当前容器的父容器中定义的对象引用

```

### bean的作用域

在我看来，bean的作用域的理解有两点：1.bean的作用范围。2.bean的生命周期的长短。

singleton：ioc容器的共享一个实例，谁都是共用这一个实例，并且他的生命周期是和容器一样，容器销毁之前都不会被销毁。

prototype：当有请求向ioc容器要实例时，容器就会创建一个新的实例并返回，该实例之后就不归容器掌管，交个使用实例的线程掌管，比如bean1= null,没有被引用，就会被视为垃圾，根据垃圾回收机制bean1就会被回收走，销毁掉。

request：

session：

global session：

