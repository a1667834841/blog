---
title: 2022-06-11_note
date: 2022-11-13 23:10:12
permalink: /pages/deeadf/
categories:
  - 每日随笔
  - 2022-06
tags:
  - 
---
**mood:** :smile:  									**date: 2022-06-11**  
## 今日计划  
------
- [ ]  
- [ ]  15个单词
## 明日计划  
------
- [ ]  
## 随写 
------



2029

2030

2697

2426

{"state":0,"percent":"39.43%","zjd":"0.3763","jg":1}

{"state":0,"percent":"39.57%","zjd":"0.3764","jg":1}

local=platid=52; ASPSESSIONIDSATSBRCT=ABHHMHNAGMBDBIPANJGPFPLM; ASPSESSIONIDCQQABCQQ=DHMMHOGBHCNJMEMMGPGJDOAL; ASPSESSIONIDCQSTDSCB=KMINNGKBCELAKGNCOEEDNNFN; ASPSESSIONIDSAQBABRR=LKEDOHDCMPDHOIPIIJFBJHCJ; p_h5_u=A0A28804-EAC3-4442-8019-806875821F52; member=photo=images%2Fv2%2Fsex1%2Egif&danwei=%D0%C2%D2%CA%CA%D0%B8%DF%BC%B6%D6%D0%D1%A7&codenum=32030519841022041x&catnum=0&platlogo=%2Fupload%2Fadmin%2Fimage%2F20200118%2F20200118120428112811%2Ejpg&danweiid=59457&name=%D6%DC%CA%BF%CF%CD&it=0&platname=%D0%EC%D6%DD%CA%D0%D7%A8%D2%B5%BC%BC%CA%F5%C8%CB%D4%B1%BC%CC%D0%F8%BD%CC%D3%FD%CD%F8&loginname=32030519841022041x&id=460343&ntimes=16&isshenyan=0&platid=52; SERVERID=ebb620124c1fe2cc9fc6cca540a799d9|1655047821|1654951477





**问题讨论**

利用注解和反射，将实现的handler收集并存放到集合中



**职责链模式**

将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。

还有一种变体，就是链上的接受对象都对请求进行处理。

**使用场景**

> 对于支持UGC（UserGeneratedContent，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就可以利用职责链模式来过滤这些敏感词。

对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用***替换敏感词）之后再发布。

第一种处理方式符合GoF给出的职责链模式的定义，

第二种处理方式是职责链模式的变体。



**课堂讨论**

- 前面在讲代理模式的时候，我们提到，Spring AOP 是基于代理模式来实现的。在实际的项目开发中，我们可以利用 AOP 来实现访问控制功能，比如鉴权、限流、日志等。今天我们又讲到，Servlet Filter、Spring Interceptor 也可以用来实现访问控制。那在项目开发中，类似权限这样的访问控制功能，我们该选择三者（AOP、Servlet Filter、Spring Interceptor）中的哪个来实现呢？有什么参考标准吗？

> 需要根据权限的颗粒度去区分，如果只是api权限，那三者都可以用来做权限，当然越早发现越好，优先选择servlet filter,但是如果涉及到数据的状态，如果需要根据用户的角色权限来是否对api开放，采用AOP更好，也可以利用spring容器的资源

- 除了我们讲到的 Servlet Filter、Spring Interceptor 之外，Dubbo Filter、Netty ChannelPipeline 也是职责链模式的实际应用案例，你能否找一个你熟悉的并且用到职责链模式的框架，像我一样分析一下它的底层实现呢？


  > Mybatis中的拦截器也使用到责任链模式，只不过是通过动态代理的方式，在多个同类型拦截器中通过遍历的方式为被拦截对象生成代理对象，然后使用生成的代理对象作为参数继续生成代理对象，直至遍历结束，拿到最外层代理对象，触发invoke方法完成链式拦截器传递
  >
  > ```java
  > @Intercepts({
  >      @Signature(type = StatementHandler.class, method = "query", args = {Statement.class, ResultHandler.class}),
  >      @Signature(type = StatementHandler.class, method = "update", args = {Statement.class}),
  >      @Signature(type = StatementHandler.class, method = "batch", args = {Statement.class})
  > })
  > public class SlowSqlInterceptor implements Interceptor {
  >  
  > ```
  >
  > 拦截器上可以指定拦截器在哪个handler上生效，并为handler创建代理对象（调用Plugin.warp()）
  >```java
  >   /**
  >    * 该方法用于创建Executor、ParameterHandler、ResultSetHandler、StatementHandler的代理对象
  >       Plugin.warp()方法首先获取自定义的拦截类上的@Signature注解上的信息并存入map，那就知道了要拦截哪些对象地哪些方法，然后判断传入的target对象是否满足拦截对象的类型，满足则创建代理对象，不满足则直接返回原对象。
  >    * @param target
  >    * @param interceptor
  >    * @return
  >       */
  >     public static Object wrap(Object target, Interceptor interceptor) {
  >
  >     // 调用getSignatureMap（）方法获取自定义插件中，通过Intercepts注解指定的方法
  >     Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
  >     Class<?> type = target.getClass();
  >     Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
  >     if (interfaces.length > 0) {
  >       return Proxy.newProxyInstance(
  >           type.getClassLoader(),
  >           interfaces,
  >           new Plugin(target, interceptor, signatureMap));
  >     }
  >     return target;
  >   }
  > ```

还有一个自己切身使用的案例，这个源头是来自阿里的一篇文章[基于 Spring 实现管道模式的最佳实践](https://blog.csdn.net/Taobaojishu/article/details/110211924)

这个也是利用了责任链模式，但是它升级成了可配置的责任链模式，可以无限叠加需要的责任链

代码我总结分为两部分，注册链路和使用执行器执行链路

- 注册链路（策略模式）

首先在配置类中申明了`Map<Context,List<Pipeline>> `类型变量，叫他注册表吧用来存放链路与上下文之间的关系，spring容器一启动，则将它注册为bean对象

- 执行器执行链路（责任链模式）

执行器有一个accept方法，传入上下文，，根据上下文class类型,查询注册表对应链路，循环执行链路逻辑（这里是同步的）



这里我为什么使用到这个，是当时因为我又很多接口都是有很多步流程，其中还包括调用第三接口，为了解决本系统与第三方系统数据不一致的情况，在`执行器执行链路`这一步，我插入了记录执行失败链路的动作，这样可以更好的发现哪次接口报错了，那一步错了，再次拿着接口参数执行请求时，只需要从失败的地方重新开始即可

不用人工的去修复脏数据，也解决了一些本系统与第三方数据不一致的问题



