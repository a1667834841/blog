---
title: 2022-08-02_note
date: 2022-11-13 23:10:12
permalink: /pages/c4b34a/
categories:
  - 每日随笔
  - 2022-08
tags:
  - 
---
**mood:** :smile:  									**date: 2022-08-02**  
## 今日计划  
------
- [ ]  
- [ ]  15个单词
## 明日计划  
------
- [ ]  
## 随写 
------

volatile为什么不能保证原子性

> volatile方式的[i++](https://www.zhihu.com/search?q=i%2B%2B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})，总共是四个步骤：
>
> i++实际为load、Increment、store、Memory Barriers 四个操作。
>
> 从最终汇编语言从面来看，volatile使得每次将i进行了修改之后，增加了一个内存屏障，保证修改的值必须刷新到主内存才能进行[内存屏障](https://www.zhihu.com/search?q=内存屏障&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})后续的指令操作。也就是`store、Memory Barriers`操作是原子的，但是`load、Increment`并不是原子的。
>
> 内存屏障是线程安全的,但是内存屏障之前的指令并不是.在某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到[寄存器](https://www.zhihu.com/search?q=寄存器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时[线程2](https://www.zhihu.com/search?q=线程2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})也执行同样的操作，获取值i==[1](https://www.zhihu.com/search?q=1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})0,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来[线程1](https://www.zhihu.com/search?q=线程1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1205806238})恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。
>
> 
>
> 作者：千帆
> 链接：https://www.zhihu.com/question/329746124/answer/1205806238
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



车辆管理

```
nacos (dev/test)
172.16.90.70:8848
账号：nacos
密码：Nacos198903*
```



mq(dev)

    rabbitmq:
        host: 192.168.1.218
        port: 5672
        virtual-host: sc_mq
        username: sc_admin
        password: RM198903*
mq(test)

    rabbitmq:
        host: 192.168.1.218
        port: 5672
        virtual-host: sc_mq_test
        username: sc_admin
        password: RM198903*
db(dev/test)

```
  datasource:
    ip: 172.16.90.71:3306
    username: root
    password: Lvcheng@123
```

## 车辆管理

**数据字典**

1. 后台插入，车辆标签，车辆类型字典信息

**一车一档**

1. 车辆导入

2. 车辆列表查询（因为`parking_car_info`最小颗粒度是车位，查询的话先要对表进行group by 车辆，在进行分页条件查询）
3. 所属小区接口 
4. 车辆列表导出（同查询逻辑）
5. 车辆信息保存（利用之前的`parking_car_info`表，保存车辆信息）
6. 用户所属小区，用户某小区所属车位



## 好物共享

app 工作台审批好物发布/申請信息（只有管理员才能审核）

- 审核同意，调用工作流接口（设置发送消息），修改记录状态为审核通过

- 审核驳回，调用工作流接口（设置发送消息），修改记录状态为审核驳回

审核中心

1. 所属小区接口

2. 所属申请人接口

3. 审核列表查询

4. 发布详情接口查询
5. 申请审核接口查询

积分中心

需要先创建积分规则，扣除或增加积分，调用积分接口，实现用户的积分改变





