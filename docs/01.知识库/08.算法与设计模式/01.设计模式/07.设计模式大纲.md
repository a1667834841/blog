# 设计原则与思想


  <iframe :src="$withBase('/markmap/设计模式.html')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>

## 八大设计原则

### solid原则

#### 单一职责原则  Single Responsibility Principle

#### 开闭原则 Open Closed Principle

#### 里氏替换原则 Liskov Substitution Principle

#### 接口隔离原则 Interface Segregation Principle

#### 依赖反转原则 Dependency Inversion Principle

## 设计模式（需要从实现方式，使用场景两方面看）

### 创建型

#### 单例模式

##### 使用场景
- 重点对资源的共享，避免了资源的重复创建
##### 实现方式
- 饿汉式
- 懒汉式
- 双重检测
#### 工厂模式
##### 实现方式
- 简单工厂
- 方法工厂
- 抽象工厂
##### 使用场景
- 封装创建过程，方便创建对象

#### 建造者模式
##### 实现方式
- 创建builder,使用builder来校验参数，创建对象
##### 使用场景
- 一般用来创建同一类型的复杂对象（比如构造参数复杂），或者不想对外暴露set方法

#### 原型模式
##### 实现方式
- 浅拷贝
- 深拷贝

##### 使用场景
- 当创建对象的成本比较大，需要的对象和已知对象的差别不大，可以拷贝已知对象来创建新的对象。

### 结构型-对象与对象之间组合成新的结构

#### 代理模式
##### 实现方式
- 静态代理
- 动态代理
#### 使用场景
- 利用已知对象对它增强，mybatis的拦截器，spring的AOP

#### 桥接模式
##### 概念
- 一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。

#### 装饰者模式
##### 概念
- 装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。
##### 特点
- 可以对原始类嵌套使用多个装饰器

#### 适配器模式
##### 实现方式
- 类适配器
- 对象适配器
##### 使用场景
- 是用来做适配，它将不兼容的接口转换为可兼容的接口

#### 门面模式
##### 概念
- 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

#### 组合模式

#### 享元模式
- 顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象


### 行为型

#### 观察者模式
##### 实现方式
- 发布-订阅型  1:N
- 生产-消费型 N:N

##### 使用场景
- 解耦数据的产生和数据的消费

#### 模板模式
##### 实现方式
- 定义好模板框架，暴露接口给子类实现
##### 使用场景
- 主要是用来扩展和复用代码

#### 策略模式
##### 实现方式
- 可以使用工厂类来创建策略，动态选择策略（if else,或者反射）

##### 使用场景
- 将对象的创建和使用解耦

#### 责任链模式
##### 实现方式
- 将流程拆分成一个一个的步骤，交给handler处理

##### 使用场景
- 适合业务复杂，多变的场景

#### 状态模式
##### 实现方式
- 分支逻辑法
- 查表法
- 态模式

##### 使用场景
- 游戏人物，审批流场景

#### 迭代模式
##### 实现方式
- 创建迭代器，遍历数据，不影响集合对象

##### 使用场景
- 遍历数据

#### 访问者模式

#### 备忘录模式
##### 使用场景
- 数据备份

#### 命令模式
#### 解释器模式
#### 中介模式




