
# 为什么有持久化机制背景
> 通过 redis操作数据时，更多的时候是通过内存和cpu打交道，所以会特别快，但是内存有个缺点就是，一断电内存中的数据就没有了，那redis作者还是想尽可能的不丢失内存中的数据，所以redis也有自己的持久化机制。


## aof机制

redis 执行完命令，会将执行成功的命令写入aof日志，当redis宕机后，恢复数据可以通过aof日志重新执行命令即可。


## 如何配置AOF？

默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：

```conf
# appendonly参数开启AOF持久化 默认不开启
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
```




### aof写回策略
**因为redis 写aof日志到磁盘具有风险：**

1. 命令执行完，aof日志还没来得及写入磁盘，宕机了，那么这个时间段内的数据不能被恢复。

2. 因为写入aof日志是使用主线程，如果写入磁盘数据变慢，会影响下面的命令操作。



**所以开发者将aof日志写回磁盘的策略提取出来，方便不同场景来不同使用**

- Always 同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
- Everysec 每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- No 操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。


### aof写回机制

**因为redis aof日志不断地append 会越来越大，影响效率；**

1. 影响插入效率，命令执行的效率；
2. 使用aof日志恢复的消耗的时间也会变；

**所以有了重写日志机制**

>  将相同键的操作，移除之前的，保留最新的一条（清除冗余命令）

aof 重写过程

一个拷贝，两处日志
1. 拷贝：主线程fork 子进程，将主线程的内存拷贝一份（这时候只是拷贝数据结构和指针，真正开辟内存空间是在主线程执行命令的时候）

2. 两处日志：操作命令 会同时写入aof日志的缓存区和新的aof重写日志的缓存区，缓存区的数据都会刷入到各自的磁盘文件中，如果aof重写日志同步完后，重命名然后替换原来的aof文件

![aof 重写过程](https://static001.geekbang.org/resource/image/57/e1/5770a4f81fb0469656fef2b35d354fe1.jpg)


**注意上图的不是子线程，而是子进程！**

使用**子进程**，而不是**子线程**是为了减少对资源的竞争

## redis 利用aof还原数据的过程
1. 建立无网络连接的伪客户端
2. 读取aof文件一条命令
3. 伪客户端执行命令
4. 重复（2,3）直到全部执行完毕

![image-20221020154536842](https://img.ggball.top/img/image-20221020154536842.png?picGo)

## redis和mysql 对比

mysql: 在事务提交时，数据写入缓存池，redo log文件写入磁盘才算事务结束，mysql服务宕机时，会利用redo log 恢复 已提交事务 但是未写入磁盘的数据。**先写日志，再写磁盘**

redis: aof 先执行命令，再写aof日志（好处就是 1.避免错误命令被记录，导致恢复数据有问题，2.不会阻塞命令执行操作）


>引用 《redis设计与实现》

![image-20221020140710803](https://img.ggball.top/img/image-20221020140710803.png?picGo)


