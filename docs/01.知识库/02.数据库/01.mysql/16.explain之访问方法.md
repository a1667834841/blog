
> MySQL 执行查询语句的方式称之为 `访问方法` 或者 `访问类型`

## 访问方法

**const**：通**过主键或者唯一二级索引列与常数的等值**比较来**定位一条记录**。意思是常数级别的，代价是可以忽略不计的。不过这种 const 访问方法只能在主键

列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，

这个const 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）。

> 对于唯一二级索引来说，查询该列为 NULL 值的情况比较特殊，比如这样：
>
> SELECT * FROM single_table WHERE key2 IS NULL;
>
> 因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用 const 访问方法来执行

**ref：**搜索条件为二级索引列与常数等值比较来**定位多条记录**，采用二级索引来执行查询的访问方法

**ref_or_null：** 当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是ref_or_null

**range：** 利用索引进行范围匹配的访问方法。

**index：**

看下边这个查询：

```
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

由于 key_part2 并不是联合索引 idx_key_part 最左索引列，所以我们无法使用 ref 或者 range 访问方法来执行这个语句。但是这个查询符合下边这两个条件：

- 它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引 idx_key_part 又包含这三个列。
- 搜索条件中只有 key_part2 列。这个列也包含在索引 idx_key_part 中。

也就是说我们可以直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = 'abc' 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , 

key_part2 , key_part3 列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，

而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接**遍历二级索引比直接遍历聚簇索引的成本要小很多**，设计 MySQL 

的大叔就把这种**采用遍历二级索引记录的执行方式称之为： index 。**



**all：**

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于 InnoDB 表来说也就是直接扫描聚簇索引，设计 MySQL 的大叔把这种使用全表扫描执行查询的方式称之为： all 。



## MySQL 在某些特定的情况下才可能会使用到 Intersection 索引合并。

情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能
出现只出现匹配部分列的情况。

情况二：主键列可以是范围匹配