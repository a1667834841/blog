---
title: 类加载器
date: 2021-10-08 19:46:04
permalink: /pages/84b402/
categories:
  - 笔记
  - java
  - jvm
tags:
  - 
---







# jvm类加载器

![image-20210329222126460](https://img.ggball.top/image-20210329222126460.png)

## 启动类加载器（Bootstrap ClassLoader）


 这个类加载器使用C++语言实现的，是虚拟机自身的一部分，这个类加载器负责加载存放在
`<JAVA_HOME>\lib`目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类
库加载到虚拟机的内存中.

## 扩展器加载类（Extension Class Loader）

这个类加载器是在类`sun.misc.Launcher$ExtClassLoader`中以Java代码的形式实现的。它负责加载`<JAVA_HOME>\lib\ext`目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。一些常见的Java扩展类库，例如Java Cryptography Extension (JCE)提供了密码学扩展，Java Database Connectivity (JDBC)提供了数据库连接功能等；第三方扩展库，常见的日志框架如Log4j、SLF4J和Logback，以及一些常用的工具库如Apache Commons系列等，都在由它加载。


## 应用程序类加载器（Application Class Loader）

这个类加载器由`sun.misc.Launcher$AppClassLoader`来实现。它负责加载用户类路径（ClassPath）上所有的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


## 自定义类加载器

用户继承`java.lang.ClassLoader`类,重写`findClass`方法，加载class文件逻辑，下面是实例：

```java

// 创建一个类，继承自java.lang.ClassLoader类。例如，您可以创建一个名为CustomClassLoader的类。

//在自定义类加载器中，至少需要实现findClass方法。这个方法负责根据类的名称查找并加载字节码。
//可以通过重写findClass方法来定义您自己的类加载逻辑。一般情况下，您可以从指定的位置（文件系统、网络等）读取类的字节码，并通过调用defineClass方法将字节码转换为一个Class对象。

public class CustomClassLoader extends ClassLoader {
    
    @Override
    protected Class<?> findClass(String className) throws ClassNotFoundException {
        // 自定义加载逻辑，根据类名称加载字节码
        byte[] classBytes = loadClassBytes(className);
        return defineClass(className, classBytes, 0, classBytes.length);
    }

    private byte[] loadClassBytes(String className) {
        // 从指定位置加载类的字节码，例如从文件系统、网络等
        // 返回加载的字节码数据
    }
}

```
## 双亲委派机制

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这**个请求委派给父类加载器去完成**，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该**传送到最顶层的启动类加载器**中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，**子加载器才会尝试自己去完成加载**。


###  双亲委派机制 安全问题

如果自定义命名了Java的核心类，比如java.lang.String

如果没有双亲委派机制，那就直接使用自定义的加载器加载类，会造成安全问题
#### 例子：
当Java虚拟机启动时，会创建一个启动类加载器（Bootstrap ClassLoader），它是由虚拟机实现的，并不是Java类。启动类加载器负责加载Java核心类库，其中包括java.lang.Object类。

当应用程序需要加载java.lang.Object类时，类加载器首先会委派给父类加载器，也就是启动类加载器。由于启动类加载器已经加载了Java核心类库，包括java.lang.Object类，所以无论应用程序的类加载器如何实现，都不会加载自己的java.lang.Object类。这样就确保了java.lang.Object类的唯一性和完整性，防止了对其的篡改。

假设有恶意代码想要篡改java.lang.Object类，它会尝试在自己的类加载器中加载java.lang.Object类并进行修改。但由于双亲委派机制的存在，加载java.lang.Object类的请求会被委派给父类加载器，而父类加载器会成功加载并返回原始的java.lang.Object类。因此，即使有恶意代码存在，它也无法修改或替换java.lang.Object类的定义。




#### 如何破坏双亲委派机制

其实只要在自定义的类加载器中，不委派父加载器即可

```java
public class CustomClassLoader extends ClassLoader {

    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        // 不再委派给父类加载器，直接尝试加载类
        Class<?> loadedClass = findLoadedClass(name);
        if (loadedClass == null) {
            byte[] classBytes = loadClassBytes(name);
            loadedClass = defineClass(name, classBytes, 0, classBytes.length);
        }
        if (resolve) {
            resolveClass(loadedClass);
        }
        return loadedClass;
    }

    private byte[] loadClassBytes(String className) {
        // 加载类的字节码，例如从文件系统、网络等
        // 返回加载的字节码数据
    }
}

```


> 注意：判断类的相同，即使加载的类是同一个，也要看看类加载器是否是同一个，如果不是同一个，jvm会存在两个类对象。







# 类加载过程

<img src="https://img.ggball.top/image-20210329222725748.png" alt="image-20210329222725748"  />

加载（loading）：ClassLoader将二进制流（可能为class文件，从ZIP压缩包中读取，从网络读取......）读取为字节码文件，然后再根据defindClass方法在java堆中实例化class对象

连接（linking）：

  1. 验证：验证.class文件的字节流中包含的信息使符合当前虚拟机的要求的，并不会危害虚拟机自身的安全

     验证步骤：
     - 文件格式验证: 是否符合class文件格式，且能被当前jvm版本所处理，例如以魔数开头，版本校验等。
     - 元数据验证：对字节码描述信息进行语义分析，判断class类是不是继承了Object类，或者检查是否继承了不该继承的类，比如继承了final修饰的类
     - 字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为
     
     - 符号引用验证：最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。检查的内容有，符号引用中通过字符串描述的全限定名是否能找到对应的类，在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。

  2. 准备：静态变量赋默认值（例如，static int val = 123;不是将val赋值为123，而是0）

  3. 解析: 是Java虚拟机将常量池内的符号引用替换为直接引用的过程

初始化（initializing）: 调用初始化代码<cinit> ,给静态变量赋初始值



# 创建对象过程

![image-20210405000536565](D:\project\vscode\vuepress-theme-reco-demo\my-blog\blogs\笔记\java\jvm\类加载器.assets\image-20210405000536565.png)

比如 new了一个对象，它含有不是静态的成员变量，加载过程是;

1. class loading
2. class linking
3. class initializing
4. 先去内存申请一块内存空间
5. 成员变量赋默认值
6. 调用构造方法
7. 成员变量才会被赋初始值



# 数据类型的默认值介绍

![image-20210404201423487](D:\project\vscode\vuepress-theme-reco-demo\my-blog\blogs\笔记\java\jvm\类加载器.assets\image-20210404201423487.png)

```
字节码:
其实更类似汇编语言的造型，当然字节码并不是汇编也不是二进制代码，这个格式是只有jvm才能解释执行的。
```

