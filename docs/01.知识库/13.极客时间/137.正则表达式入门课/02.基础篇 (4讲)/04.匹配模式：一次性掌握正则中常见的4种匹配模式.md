--- 
author: 涂伟忠
article: false
sidebar: true
tags: 
  - 极客时间 
--- 
<span data-slate-object="text" data-key="1213"><span data-slate-leaf="true" data-offset-key="1213:0" data-first-offset="true"><span data-slate-string="true">你好，我是涂伟忠。今天我们一起来学习正则中的匹配模式（Match Mode）。</span></span></span>
<span data-slate-object="text" data-key="1215"><span data-slate-leaf="true" data-offset-key="1215:0" data-first-offset="true"><span data-slate-string="true">所谓匹配模式，指的是正则中一些</span></span></span><span data-slate-object="text" data-key="1216"><span data-slate-leaf="true" data-offset-key="1216:0" data-first-offset="true"><span class="se-189c1a7a" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">改变元字符匹配行为</span></span></span></span><span data-slate-object="text" data-key="1217"><span data-slate-leaf="true" data-offset-key="1217:0" data-first-offset="true"><span data-slate-string="true">的方式，比如匹配时不区分英文字母大小写。常见的匹配模式有 4 种，分别是不区分大小写模式、点号通配模式、多行模式和注释模式。我们今天主要来讲一下这 4 种模式。</span></span></span>
<span data-slate-object="text" data-key="1219"><span data-slate-leaf="true" data-offset-key="1219:0" data-first-offset="true"><span data-slate-string="true">需要注意的是，这里的“模式”对应的是英文中的 mode，而不是 pattern。有些地方会把正则表达式 pattern 也翻译成模式，你在网上看到的技术文章中讲的正则模式，有可能指的是正则表达式本身，这一点你需要注意区别。</span></span></span>
## 不区分大小写模式（Case-Insensitive）
<span data-slate-object="text" data-key="1223"><span data-slate-leaf="true" data-offset-key="1223:0" data-first-offset="true"><span data-slate-string="true">首先，我们来看一下不区分大小写模式。它有什么用呢？学一个知识的时候，我一般喜欢先从它的应用出发，这样有时候更能激发我学习的兴趣，也更容易看到学习成果。</span></span></span>
<span data-slate-object="text" data-key="1225"><span data-slate-leaf="true" data-offset-key="1225:0" data-first-offset="true"><span data-slate-string="true">下面我来举个例子说明一下。在进行文本匹配时，我们要关心单词本身的意义。比如要查找单词 cat，我们并不需要关心单词是 CAT、Cat，还是 cat。根据之前我们学到的知识，你可能会把正则写成这样：</span></span></span><span data-slate-object="text" data-key="1226"><span data-slate-leaf="true" data-offset-key="1226:0" data-first-offset="true"><span class="se-f7169e14" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">[Cc][Aa][Tt]</span></span></span></span><span data-slate-object="text" data-key="1227"><span data-slate-leaf="true" data-offset-key="1227:0" data-first-offset="true"><span data-slate-string="true">，这样写虽然可以达到目的，但不够直观，如果单词比较长，写起来容易出错，阅读起来也比较困难。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/33/9d/334501a163b809125f62821edb1cfb9d.png)
<span data-slate-object="text" data-key="1230"><span data-slate-leaf="true" data-offset-key="1230:0" data-first-offset="true"><span data-slate-string="true">那么有没有更好的办法来实现这个需求呢？这时候不区分大小写模式就派上用场了。</span></span></span>
<span data-slate-object="text" data-key="1232"><span data-slate-leaf="true" data-offset-key="1232:0" data-first-offset="true"><span data-slate-string="true">我们前面说了，不区分大小写是匹配模式的一种。当我们把</span></span></span><span data-slate-object="text" data-key="1233"><span data-slate-leaf="true" data-offset-key="1233:0" data-first-offset="true"><span class="se-69009cd5" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">模式修饰符</span></span></span></span><span data-slate-object="text" data-key="1234"><span data-slate-leaf="true" data-offset-key="1234:0" data-first-offset="true"><span data-slate-string="true">放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 </span></span></span><span data-slate-object="text" data-key="1235"><span data-slate-leaf="true" data-offset-key="1235:0" data-first-offset="true"><span class="se-288a4057" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">(? 模式标识)</span></span></span></span><span data-slate-object="text" data-key="1236"><span data-slate-leaf="true" data-offset-key="1236:0" data-first-offset="true"><span data-slate-string="true"> 的方式来表示的。  我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。在不区分大小写模式中，由于不分大小写的英文是 Case-</span></span></span><span data-slate-object="text" data-key="1237"><span data-slate-leaf="true" data-offset-key="1237:0" data-first-offset="true"><span class="se-66ef2b12" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">I</span></span></span></span><span data-slate-object="text" data-key="1238"><span data-slate-leaf="true" data-offset-key="1238:0" data-first-offset="true"><span data-slate-string="true">nsensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成  </span></span></span><span data-slate-object="text" data-key="1239"><span data-slate-leaf="true" data-offset-key="1239:0" data-first-offset="true"><span class="se-57e43e9c" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">(?i)</span></span></span></span><span data-slate-object="text" data-key="1240"><span data-slate-leaf="true" data-offset-key="1240:0" data-first-offset="true"><span data-slate-string="true">cat。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/f3/01/f30f895ed1754e1d1a576a59835b9701.png)
<span data-slate-object="text" data-key="1243"><span data-slate-leaf="true" data-offset-key="1243:0" data-first-offset="true"><span data-slate-string="true">你看，和</span></span></span><span data-slate-object="text" data-key="1244"><span data-slate-leaf="true" data-offset-key="1244:0" data-first-offset="true"><span class="se-a4c8c043" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">[Cc][Aa][Tt] </span></span></span></span><span data-slate-object="text" data-key="1245"><span data-slate-leaf="true" data-offset-key="1245:0" data-first-offset="true"><span data-slate-string="true">相比，这样是不是清晰简洁了很多呢？</span></span></span>
<span data-slate-object="text" data-key="1247"><span data-slate-leaf="true" data-offset-key="1247:0" data-first-offset="true"><span data-slate-string="true">我们也可以用它来尝试匹配两个连续出现的 cat，如下图所示，你会发现，即便是第一个 cat 和第二个 cat 大小写不一致，也可以匹配上。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/ee/e0/eeb074edfd6d052407130311aff8cae0.png)
<span data-slate-object="text" data-key="1250"><span data-slate-leaf="true" data-offset-key="1250:0" data-first-offset="true"><span data-slate-string="true">我给到了你一个测试链接，你可以在这里试试不区分大小写模式：</span></span></span>
<a data-slate-type="link" data-slate-object="inline" data-key="1252" class="se-94077143 se-d4f26ae6"><span data-slate-object="text" data-key="1253"><span data-slate-leaf="true" data-offset-key="1253:0" data-first-offset="true"><span data-slate-string="true">https://regex101.com/r/x1lg4P/1</span></span></span></a><span data-slate-object="text" data-key="1254"><span data-slate-leaf="true" data-offset-key="1254:0" data-first-offset="true"><span data-slate-string="true">。</span></span></span>
<span data-slate-object="text" data-key="1256"><span data-slate-leaf="true" data-offset-key="1256:0" data-first-offset="true"><span data-slate-string="true">如果我们想要前面匹配上的结果，和第二次重复时的大小写一致，那该怎么做呢？我们只需要用括号把</span></span></span><span data-slate-object="text" data-key="1257"><span data-slate-leaf="true" data-offset-key="1257:0" data-first-offset="true"><span class="se-6ca97c9c" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">修饰符和正则 cat 部分</span></span></span></span><span data-slate-object="text" data-key="1258"><span data-slate-leaf="true" data-offset-key="1258:0" data-first-offset="true"><span data-slate-string="true">括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容。同样的，我在</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1259" class="se-94077143 se-d4f26ae6"><span data-slate-object="text" data-key="1260"><span data-slate-leaf="true" data-offset-key="1260:0" data-first-offset="true"><span data-slate-string="true">这里</span></span></span></a><span data-slate-object="text" data-key="1261"><span data-slate-leaf="true" data-offset-key="1261:0" data-first-offset="true"><span data-slate-string="true">给你放了一个测试链接，你可以自己看一下。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/b6/7e/b630d1374a88eb1591f223e86f11c37e.png)
<span data-slate-object="text" data-key="1264"><span data-slate-leaf="true" data-offset-key="1264:0" data-first-offset="true"><span data-slate-string="true">需要注意的是，这里正则写成了 ((?i)cat) \1，而不是 ((?i)(cat)) \1。也就是说，我们给修饰符和 cat 整体加了个括号，而原来 cat 部分的括号去掉了。如果 cat 保留原来的括号，即 ((?i)(cat)) \1，这样正则中就会有两个子组，虽然结果也是对的，但这其实没必要。在上一讲里我们已经讲解了相关的内容，如果忘记了你可以回去复习一下。</span></span></span>
<span data-slate-object="text" data-key="1266"><span data-slate-leaf="true" data-offset-key="1266:0" data-first-offset="true"><span data-slate-string="true">到这里，我们再进阶一下。如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写。</span></span></span>
<span data-slate-object="text" data-key="1268"><span data-slate-leaf="true" data-offset-key="1268:0" data-first-offset="true"><span data-slate-string="true">通过上面的学习，你应该能很快写出相应的正则，也就是 (</span></span></span><span data-slate-object="text" data-key="1269"><span data-slate-leaf="true" data-offset-key="1269:0" data-first-offset="true"><span class="se-e42fe668" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">(?i)</span></span></span></span><span data-slate-object="text" data-key="1270"><span data-slate-leaf="true" data-offset-key="1270:0" data-first-offset="true"><span data-slate-string="true">the) cat。实现的效果如下：</span></span></span>
![图片](https://static001.geekbang.org/resource/image/80/7e/802f69e2c0fddf341ada804c20a8767e.png)
<span data-slate-object="text" data-key="1273"><span data-slate-leaf="true" data-offset-key="1273:0" data-first-offset="true"><span data-slate-string="true">我把部分区分大小写，部分不区分大小写的测试链接放在</span></span></span><a data-slate-type="link" data-slate-object="inline" data-key="1274" class="se-94077143 se-d4f26ae6"><span data-slate-object="text" data-key="1275"><span data-slate-leaf="true" data-offset-key="1275:0" data-first-offset="true"><span data-slate-string="true">这里</span></span></span></a><span data-slate-object="text" data-key="1276"><span data-slate-leaf="true" data-offset-key="1276:0" data-first-offset="true"><span data-slate-string="true">，你可以看一下。</span></span></span>
<span data-slate-object="text" data-key="1278"><span data-slate-leaf="true" data-offset-key="1278:0" data-first-offset="true"><span data-slate-string="true">有一点需要你注意一下，上面讲到的通过</span></span></span><span data-slate-object="text" data-key="1279"><span data-slate-leaf="true" data-offset-key="1279:0" data-first-offset="true"><span class="se-fcb28bbe" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">修饰符指定匹配模式</span></span></span></span><span data-slate-object="text" data-key="1280"><span data-slate-leaf="true" data-offset-key="1280:0" data-first-offset="true"><span data-slate-string="true">的方式，在大部分编程语言中都是可以直接使用的，但在 JS 中我们需要使用 /regex/</span></span></span><span data-slate-object="text" data-key="1281"><span data-slate-leaf="true" data-offset-key="1281:0" data-first-offset="true"><span class="se-2da474c9" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">i</span></span></span></span><span data-slate-object="text" data-key="1282"><span data-slate-leaf="true" data-offset-key="1282:0" data-first-offset="true"><span data-slate-string="true"> 来指定匹配模式。在编程语言中通常会提供一些预定义的常量，来进行匹配模式的指定。比如 Python 中可以使用 re.IGNORECASE 或 re.I ，来传入正则函数中来表示不区分大小写。我下面给出了你一个示例，你可以看一下。</span></span></span>
```java 
>>> import re
>>> re.findall(r"cat", "CAT Cat cat", re.IGNORECASE)
['CAT', 'Cat', 'cat']

 ``` 
<span data-slate-object="text" data-key="1304"><span data-slate-leaf="true" data-offset-key="1304:0" data-first-offset="true"><span data-slate-string="true">到这里我简单总结一下不区分大小写模式的要点：</span></span></span>
- 不区分大小写模式的指定方式，使用模式修饰符 (?i)；
- 修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则；
- 使用编程语言时可以使用预定义好的常量来指定匹配模式。
## 点号通配模式（DotAll）
<span data-slate-object="text" data-key="1315"><span data-slate-leaf="true" data-offset-key="1315:0" data-first-offset="true"><span data-slate-string="true">在基础篇的第一讲里，我为你讲解了元字符相关的知识，你还记得英文的点（.）有什么用吗？它可以匹配上任何符号，但不能匹配换行。当我们需要匹配真正的“任意”符号的时候，可以使用 [\s\S] 或 [\d\D] 或 [\w\W] 等。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/e2/84/e2184c4583ff4f32a14c1cb6f1bc9184.png)
<span data-slate-object="text" data-key="1318"><span data-slate-leaf="true" data-offset-key="1318:0" data-first-offset="true"><span data-slate-string="true">但是这么写不够简洁自然，所以正则中提供了一种模式，让英文的点（.）可以匹配上包括换行的任何字符。</span></span></span>
<span data-slate-object="text" data-key="1320"><span data-slate-leaf="true" data-offset-key="1320:0" data-first-offset="true"><span data-slate-string="true">这个模式就是</span></span></span><span data-slate-object="text" data-key="1321"><span data-slate-leaf="true" data-offset-key="1321:0" data-first-offset="true"><span class="se-ff39cee4" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">点号通配模式</span></span></span></span><span data-slate-object="text" data-key="1322"><span data-slate-leaf="true" data-offset-key="1322:0" data-first-offset="true"><span data-slate-string="true">，有很多地方把它称作单行匹配模式，但这么说容易造成误解，毕竟它与多行匹配模式没有联系，因此在课程中我们统一用更容易理解的“点号通配模式”。</span></span></span>
<span data-slate-object="text" data-key="1324"><span data-slate-leaf="true" data-offset-key="1324:0" data-first-offset="true"><span data-slate-string="true">单行的英文表示是 </span></span></span><span data-slate-object="text" data-key="1325"><span data-slate-leaf="true" data-offset-key="1325:0" data-first-offset="true"><span class="se-33aeda85" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">S</span></span></span></span><span data-slate-object="text" data-key="1326"><span data-slate-leaf="true" data-offset-key="1326:0" data-first-offset="true"><span data-slate-string="true">ingle Line，单行模式对应的修饰符是 </span></span></span><span data-slate-object="text" data-key="1327"><span data-slate-leaf="true" data-offset-key="1327:0" data-first-offset="true"><span class="se-4f0d3819" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">(?s)</span></span></span></span><span data-slate-object="text" data-key="1328"><span data-slate-leaf="true" data-offset-key="1328:0" data-first-offset="true"><span data-slate-string="true">，我还是选择用 the cat 来给你举一个点号通配模式的例子。如下图所示：</span></span></span>
![图片](https://static001.geekbang.org/resource/image/59/52/59b4b56c3d5852b3412185dc3a3de052.png)
<span data-slate-object="text" data-key="1331"><span data-slate-leaf="true" data-offset-key="1331:0" data-first-offset="true"><span data-slate-string="true">需要注意的是，JavasScript 不支持此模式，那么我们就可以使用前面说的[\s\S]等方式替代。在 Ruby 中则是用 Multiline，来表示点号通配模式（单行匹配模式），我猜测设计者的意图是把点（.）号理解成“能匹配多行”。</span></span></span>
## 多行匹配模式（Multiline）
<span data-slate-object="text" data-key="1335"><span data-slate-leaf="true" data-offset-key="1335:0" data-first-offset="true"><span data-slate-string="true">讲完了点号通配模式，我们再来看看多行匹配模式。通常情况下，^ 匹配整个字符串的开头，</span></span></span><span data-slate-type="inline-katex" data-slate-object="inline" data-key="1336"><span data-slate-leaf="true"><span data-slate-string="true" class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.363em;vertical-align:0em;"></span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">尾</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">多</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">匹</span><span class="mord cjk_fallback">配</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">就</span><span class="mord"><span class="mord cjk_fallback">是</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord cjk_fallback mtight">和</span></span></span></span></span></span></span></span></span></span></span></span></span><span data-slate-object="text" data-key="1338"><span data-slate-leaf="true" data-offset-key="1338:0" data-first-offset="true"><span data-slate-string="true"> 的匹配行为。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/09/b9/09cbdacb73c7c66423a878f452c87fb9.png)
<span data-slate-object="text" data-key="1341"><span data-slate-leaf="true" data-offset-key="1341:0" data-first-offset="true"><span data-slate-string="true">多行模式的作用在于，使  ^ 和 $ 能匹配上</span></span></span><span data-slate-object="text" data-key="1342"><span data-slate-leaf="true" data-offset-key="1342:0" data-first-offset="true"><span class="se-285e59a1" data-slate-type="bold" data-slate-object="mark"><span data-slate-string="true">每行</span></span></span></span><span data-slate-object="text" data-key="1343"><span data-slate-leaf="true" data-offset-key="1343:0" data-first-offset="true"><span data-slate-string="true">的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。</span></span></span>
![图片](https://static001.geekbang.org/resource/image/e3/19/e3bf8bd8f9d594472a940d4a7e4f2f19.png)
<span data-slate-object="text" data-key="1346"><span data-slate-leaf="true" data-offset-key="1346:0" data-first-offset="true"><span data-slate-string="true">这个模式有什么用呢？在处理日志时，如果日志以时间开头，有一些日志打印了堆栈信息，占用了多行，我们就可以使用多行匹配模式，在日志中匹配到以时间开头的每一行日志。</span></span></span>
<span data-slate-object="text" data-key="1348"><span data-slate-leaf="true" data-offset-key="1348:0" data-first-offset="true"><span data-slate-string="true">值得一提的是，正则中还有 \A 和 \z（Python 中是 \Z） 这两个元字符容易混淆，\A 仅匹配整个字符串的开始，\z 仅匹配整个字符串的结束，在多行匹配模式下，它们的匹配行为不会改变，如果只想匹配整个字符串，而不是匹配每一行，用这个更严谨一些。</span></span></span>
## 注释模式（Comment）
<span data-slate-object="text" data-key="1352"><span data-slate-leaf="true" data-offset-key="1352:0" data-first-offset="true"><span data-slate-string="true">在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 (?#comment) 来表示。</span></span></span>
<span data-slate-object="text" data-key="1354"><span data-slate-leaf="true" data-offset-key="1354:0" data-first-offset="true"><span data-slate-string="true">比如我们可以把单词重复出现一次的正则 (\w+) \1 写成下面这样，这样的话，就算不是很懂正则的人也可以通过注释看懂正则的意思。</span></span></span>
```java 
(\w+)(?#word) \1(?#word repeat again)

 ``` 
![图片](https://static001.geekbang.org/resource/image/44/ef/44f064fc587d5e5fd3538849b78039ef.png)
<span data-slate-object="text" data-key="1361"><span data-slate-leaf="true" data-offset-key="1361:0" data-first-offset="true"><span data-slate-string="true">在很多编程语言中也提供了 x 模式来书写正则，也可以起到注释的作用。我用 Python3 给你举了一个例子，你可以参考一下。</span></span></span>
```java 
import re

regex = r'''(?mx)  # 使用多行模式和x模式
^          # 开头
(\d{4})    # 年
(\d{2})    # 月
$          # 结尾
'''

re.findall(regex, '202006\n202007')
# 输出结果 [('2020', '06'), ('2020', '07')]

 ``` 
<span data-slate-object="text" data-key="1388"><span data-slate-leaf="true" data-offset-key="1388:0" data-first-offset="true"><span data-slate-string="true">需要注意的是在 x 模式下，所有的换行和空格都会被忽略。为了换行和空格的正确使用，我们可以通过把空格放入字符组中，或将空格转义来解决换行和空格的忽略问题。我下面给了你一个示例，你可以看看。</span></span></span>
```java 
regex = r'''(?mx)
^          # 开头
(\d{4})    # 年
[ ]        # 空格
(\d{2})    # 月
$          # 结尾
'''

re.findall(regex, '2020 06\n2020 07')
# 输出结果 [('2020', '06'), ('2020', '07')]

 ``` 
## 总结
<span data-slate-object="text" data-key="1415"><span data-slate-leaf="true" data-offset-key="1415:0" data-first-offset="true"><span data-slate-string="true">最后，我来给你总结一下，正则中常见的四种匹配模式，分别是：不区分大小写、点号通配模式、多行模式和注释模式。</span></span></span>
- 不区分大小写模式，它可以让整个正则或正则中某一部分进行不区分大小写的匹配。
- 点号通配模式也叫单行匹配，改变的是点号的匹配行为，让其可以匹配任何字符，包括换行。
- 多行匹配说的是 ^ 和 $ 的匹配行为，让其可以匹配上每行的开头或结尾。
- 注释模式则可以在正则中添加注释，让正则变得更容易阅读和维护。
![图片](https://static001.geekbang.org/resource/image/02/8b/0263a31d40a705e3941b1c7367a3208b.png)
## 思考题
<span data-slate-object="text" data-key="1429"><span data-slate-leaf="true" data-offset-key="1429:0" data-first-offset="true"><span data-slate-string="true">最后，我们来做一个小练习吧。HTML 标签是不区分大小写的，比如我们要提取网页中的 head 标签中的内容，用正则如何实现呢？</span></span></span>
![图片](https://static001.geekbang.org/resource/image/74/69/74504bef5656171815b42899f1600969.png)
<span data-slate-object="text" data-key="1432"><span data-slate-leaf="true" data-offset-key="1432:0" data-first-offset="true"><span data-slate-string="true">你可以动手试一试，用文本编辑器或你熟悉的编程语言来实现，经过不断练习你才能更好地掌握学习的内容。</span></span></span>
<span data-slate-object="text" data-key="1434"><span data-slate-leaf="true" data-offset-key="1434:0" data-first-offset="true"><span data-slate-string="true">今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</span></span></span>
精选评论 
 ------- 
 ::: details 
<a style='font-size:1.5em;font-weight:bold'>furuhata</a> 


 ```java 
(?si)<head>(.*)<\/head>
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>William</a> 


 ```java 
刊误
JavaScript已经支持单行模式了。支持 gimsuy 共6个flag。
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags

测试代码：(打开任意一个网站，提取head标签内内容)
document.querySelectorAll('html')[0].innerHTML.match(/<head>.*<\/head>/gsi)[0]
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>Harmony Chang</a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'>KaKa</a> 


 ```java 
老师能不能多讲解下 实际应用啊 好比我是前端，更主要关注的是js方面的。可是听了几节你将的课以后，还是不知道如何在js中使用。也仅仅只会在你给的一个专门链接里进行测试。可是在js中呢 真的是一脸懵逼。可能是我太菜了[旺柴]，也正是因为我菜  所以我才买了这门课程 哈哈哈哈， 麻烦老师回我一下啊
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>HardToGiveaName</a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'>一步</a> 


 ```java 
PCRE: (?i)<head>(?s).+<\/head>
在 JS  中不支持 ?i 模式的书写形式： /<head>.+<\/head>/igs
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>虹炎</a> 


 ```java 
我的答案：
第一步查找：(?i)<head>((?s).+)<\/head>
第二步替换：\1
为什么是\1 而不是\2 , 我觉得是模式修饰符的括号不算分组。老师，你怎么看？
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>虹炎</a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'>前端路上的小学生</a> 


 ```java 
课后习题答案： (?i)<head>([\s\S]*)<\/head>
在JavaScript下：/<head>([\s\S]*)<\/head>/gi   需要使用 RegExp.$1 取出值
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>前端路上的小学生</a> 


 ```java 
/(<head>)[\s\S]+<\/head>/gi

javascript 语言下使用
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>宁悦</a> 


 ```java 
(?i)^<head>(?s).+</head>$
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>Billions</a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'>小美</a> 


 ```java 
老师，您多行匹配那一部分文章，在编辑时被转译成了katex格式了，还有文章最下面的脑图，还是关于多行匹配的，您文字，匹配，写成了区配。
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>Peace</a> 


 ```java 
(?si)<(head).*?>.*?<\/\1>
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>Geek_bbbd6a</a> 


 ```java 
老师请问下，
一个有json语法错误的字符串，如下：

    &#34;closeBtn&#34;:&#34;close&#34;,
},
&#34;ecp_webcore_component_EntitySelect&#34;:{

简单想用正则把多余的逗号&#34;,&#34;替换掉。
在正则验证器里【\&#34;,\n{】很容易匹配，然后用【&#34;\&#34;\n{&#34;】替换掉。
但相同的正则在Java运行时就会报错(Pattern.SyntaxException)异常，请问老师，此正则在JAVA应该如何修改?
听说JAVA正则匹配有逻辑错误，各种&#34;\&#34;转义容易出问题，有替代解决方案吗？简单讲就是，在正则匹配器内可以运行的正则表达式如何能在JAVA中直接使用呢？
谢谢。

```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>Isaac</a> 


 ```java 
(?si)<head(\s(profile|accesskey|class|contenteditable|contextmenu|data-[\w\d]|dir|draggable|dropzone|hidden|id|lang|spellcheck|style|tabindex|title|translate)(=&#34;.*?&#34;)?)*>.*<\/head>

https://regex101.com/r/x1lg4P/6

(?si)<head(.*?)>.*<\/head>

https://regex101.com/r/x1lg4P/5
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>seerjk</a> 


 ```java 
v1: <(?:(?i)head)>(?#case insensitive <head>)((?s).+)(?#match \n)<\/(?:(?i)head)>(?#case insensitive </head>)
v1版本比较复杂，从做向右考虑：<(?:(?i)head)> 匹配不区分大小写的 <head> 并不保存分组；((?s).+) 点号通配模式，匹配换行；<\/(?:(?i)head)> 匹配不区分大小写的 <\head> 并不保存分组；

v2: (?is)<head>(?#case insensitive <head>)(.+)(?#match \n)<\/head>(?#case insensitive </head>)
优化后把匹配模式(?i) 和 (?s) 合并提前到表达式最前面(?is)（匹配模式对整个表达式生效），且调整后不会影响结果。
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>设置昵称</a> 


 ```java 
js里面我一般用  /(?<=<head.*?>)(.*?)(?=<\/head>)/i 
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'>chengzise</a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'>我行我素</a> 


 ```java 
(?i)<head>(\D*|\d*)+(?i)<\/head>
```
 ----- 
:::