--- 
author: ç‹äº‰
article: false
sidebar: true
tags: 
  - æå®¢æ—¶é—´ 
--- 
#         æ˜¥èŠ‚7å¤©ç»ƒ | Day 6ï¼šå›¾      
ä½ å¥½ï¼Œæˆ‘æ˜¯ç‹äº‰ã€‚åˆå…­å¥½ï¼
ä¸ºäº†å¸®ä½ å·©å›ºæ‰€å­¦ï¼ŒçœŸæ­£æŒæ¡æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œæˆ‘æ•´ç†äº†æ•°æ®ç»“æ„å’Œç®—æ³•ä¸­ï¼Œå¿…çŸ¥å¿…ä¼šçš„ 30 ä¸ªä»£ç å®ç°ï¼Œåˆ† 7 å¤©å‘å¸ƒå‡ºæ¥ï¼Œä¾›ä½ å¤ä¹ å·©å›ºæ‰€ç”¨ã€‚ä»Šå¤©æ˜¯ç¬¬å…­ç¯‡ã€‚
å’Œä¹‹å‰ä¸€æ ·ï¼Œä½ å¯ä»¥èŠ±ä¸€ç‚¹æ—¶é—´ï¼Œæ¥æ‰‹å†™è¿™äº›å¿…çŸ¥å¿…ä¼šçš„ä»£ç ã€‚å†™å®Œä¹‹åï¼Œä½ å¯ä»¥æ ¹æ®ç»“æœï¼Œå›åˆ°ç›¸åº”ç« èŠ‚ï¼Œæœ‰é’ˆå¯¹æ€§åœ°è¿›è¡Œå¤ä¹ ã€‚åšåˆ°è¿™äº›ï¼Œç›¸ä¿¡ä½ ä¼šæœ‰ä¸ä¸€æ ·çš„æ”¶è·ã€‚
## å…³äºå›¾çš„å‡ ä¸ªå¿…çŸ¥å¿…ä¼šçš„ä»£ç å®ç°
### å›¾
- å®ç°æœ‰å‘å›¾ã€æ— å‘å›¾ã€æœ‰æƒå›¾ã€æ— æƒå›¾çš„é‚»æ¥çŸ©é˜µå’Œé‚»æ¥è¡¨è¡¨ç¤ºæ–¹æ³•
- å®ç°å›¾çš„æ·±åº¦ä¼˜å…ˆæœç´¢ã€å¹¿åº¦ä¼˜å…ˆæœç´¢
- å®ç° Dijkstra ç®—æ³•ã€A* ç®—æ³•
- å®ç°æ‹“æ‰‘æ’åºçš„ Kahn ç®—æ³•ã€DFS ç®—æ³•
## å¯¹åº”çš„ LeetCode ç»ƒä¹ é¢˜ï¼ˆ@Smallfly æ•´ç†ï¼‰
è‹±æ–‡ç‰ˆï¼š<a href="https://leetcode.com/problems/number-of-islands/description/">https://leetcode.com/problems/number-of-islands/description/</a>
ä¸­æ–‡ç‰ˆï¼š<a href="https://leetcode-cn.com/problems/number-of-islands/description/">https://leetcode-cn.com/problems/number-of-islands/description/</a>
è‹±æ–‡ç‰ˆï¼š<a href="https://leetcode.com/problems/valid-sudoku/">https://leetcode.com/problems/valid-sudoku/</a>
ä¸­æ–‡ç‰ˆï¼š<a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a>
åšå®Œé¢˜ç›®ä¹‹åï¼Œä½ å¯ä»¥ç‚¹å‡»â€œè¯·æœ‹å‹è¯»â€ï¼ŒæŠŠæµ‹è¯•é¢˜åˆ†äº«ç»™ä½ çš„æœ‹å‹ï¼Œè¯´ä¸å®šå°±å¸®ä»–è§£å†³äº†ä¸€ä¸ªéš¾é¢˜ã€‚
ç¥ä½ å–å¾—å¥½æˆç»©ï¼æ˜å¤©è§ï¼
![å›¾ç‰‡](https://static001.geekbang.org/resource/image/8e/d3/8e603e3d795fc0ab2698f6f5eabf14d3.jpg)
ç²¾é€‰è¯„è®º 
 ------- 
 ::: details 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
ä»Šå¤©æ ¹æ®è€å¸ˆçš„è¯¾ç¨‹ï¼Œæ€»ç»“äº†ä¸€ä¸‹å›¾çš„ç›¸å…³çŸ¥è¯†ç‚¹ï¼Œç„¶åç”¨ä»£ç å®ç°äº†ä¸€ä¸‹å›¾çš„ç›¸å…³çš„ç®—æ³•ï¼Œæ„Ÿè§‰å›¾è¿˜æ˜¯è¦éš¾äºå…¶ä»–æ•°æ®ç»“æ„ï¼Œéœ€è¦æ¥ç€å¤šç»ƒä¹ ~
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
å›¾å¾ˆå¤æ‚ğŸ˜¢
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
å®ç°å›¾çš„æ·±åº¦ä¼˜å…ˆæœç´¢ã€å¹¿åº¦ä¼˜å…ˆæœç´¢:

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

public class BFSAndDFS {

Â Â Â Â class Node {
Â Â Â Â Â Â Â Â public int value; //Node å€¼
Â Â Â Â Â Â Â Â public int in;    //å…¥åº¦ï¼šæŒ‡å‘è¯¥èŠ‚ç‚¹çš„è¾¹æœ‰å‡ æ¡
Â Â Â Â Â Â Â Â public int out;   //å‡ºåº¦ï¼šæŒ‡å‘å…¶ä»–èŠ‚ç‚¹çš„è¾¹æœ‰å‡ æ¡
Â Â Â Â Â Â Â Â public ArrayList<Node> nexts;
Â Â Â Â Â Â Â Â public ArrayList<Edge> edges;

Â Â Â Â Â Â Â Â public Node(int value) {
Â Â Â Â Â Â Â Â Â Â Â Â this.value = value;
Â Â Â Â Â Â Â Â Â Â Â Â this.in = 0;
Â Â Â Â Â Â Â Â Â Â Â Â this.out = 0;
Â Â Â Â Â Â Â Â Â Â Â Â this.nexts = new ArrayList<>();
Â Â Â Â Â Â Â Â Â Â Â Â this.edges = new ArrayList<>();
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â 
Â Â Â Â public static void bfs(Node node) {
Â Â Â Â Â Â Â Â if (node == null) {
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Queue<Node> queue = new LinkedList<>();
Â Â Â Â Â Â Â Â HashSet<Node> set = new HashSet<>();
Â Â Â Â Â Â Â Â queue.add(node);
Â Â Â Â Â Â Â Â set.add(node);
Â Â Â Â Â Â Â Â while (!queue.isEmpty()) {
Â Â Â Â Â Â Â Â Â Â Â Â Node cur = queue.poll();
Â Â Â Â Â Â Â Â Â Â Â Â System.out.print(cur.value + &#34; &#34;);
Â Â Â Â Â Â Â Â Â Â Â Â for (Node next : cur.nexts) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!set.contains(next)) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â queue.add(next);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â set.add(next);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â public static void dfs(Node node) {
Â Â Â Â Â Â Â Â if (node == null) {
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Stack<Node> stack = new Stack<>();
Â Â Â Â Â Â Â Â HashSet<Node> set = new HashSet<>();
Â Â Â Â Â Â Â Â stack.push(node);
Â Â Â Â Â Â Â Â set.add(node);
Â Â Â Â Â Â Â Â System.out.print(node.value + &#34; &#34;);
Â Â Â Â Â Â Â Â while (!stack.isEmpty()) {
Â Â Â Â Â Â Â Â Â Â Â Â Node cur = stack.pop();
Â Â Â Â Â Â Â Â Â Â Â Â for (Node next : cur.nexts) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!set.contains(next)) { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stack.push(cur);       
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â stack.push(next);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â set.add(next);         
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â System.out.print(next.value + &#34; &#34;);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;                
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 

å¹¶æŸ¥é›†â€”goå®ç°
func numIslands(grid [][]byte) int {
Â Â Â Â if len(grid) == 0 {
Â Â Â Â Â Â Â Â return 0
Â Â Â Â }

Â Â Â Â N := len(grid)*len(grid[0]) + 1

Â Â Â Â u := NewUnionSet(N)

Â Â Â Â for i := 0; i < len(grid); i ++ {
Â Â Â Â Â Â Â Â for j := 0; j < len(grid[i]); j ++ {
Â Â Â Â Â Â Â Â Â Â Â Â if grid[i][j] == '1' {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // è”é€šä¸‹è¾¹
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if i+1 < len(grid) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if grid[i+1][j] == '1' {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â u.join(i*len(grid[i])+j, (i+1)*len(grid[i])+j)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // è”é€šå³è¾¹
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if j+1 < len(grid[i]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if grid[i][j+1] == '1' {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â u.join(i*len(grid[i])+j, i*len(grid[i])+j+1)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â u.join(i*len(grid[i])+j, N-1)
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â return  u.counts() -1
}

type UnionSet []int

func NewUnionSet(n int) UnionSet {
Â Â Â Â var u UnionSet
Â Â Â Â u = make([]int, n)
Â Â Â Â for i := 0; i < len(u); i ++ {
Â Â Â Â Â Â Â Â u[i] = i
Â Â Â Â }
Â Â Â Â return u

}

func (u UnionSet) find(i int) int {
Â Â Â Â tmp := i
Â Â Â Â for u[tmp] != tmp {
Â Â Â Â Â Â Â Â tmp = u[tmp]
Â Â Â Â }

Â Â Â Â j := i
Â Â Â Â for j != tmp {
Â Â Â Â Â Â Â Â tt := u[j]
Â Â Â Â Â Â Â Â u[j] = tmp
Â Â Â Â Â Â Â Â j = tt
Â Â Â Â }

Â Â Â Â return tmp
}

func (u UnionSet) connected(i, j int) bool {
Â Â Â Â return u.find(i) == u.find(j)
}

func (u UnionSet) counts() int {
Â Â Â Â var count int
Â Â Â Â for idx, rec := range u {
Â Â Â Â Â Â Â Â if idx == rec {
Â Â Â Â Â Â Â Â Â Â Â Â count++
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â return count
}

func (u UnionSet) join(i, j int) {
Â Â Â Â x, y := u.find(i), u.find(j)
Â Â Â Â if x != y {
Â Â Â Â Â Â Â Â if y > x {
Â Â Â Â Â Â Â Â Â Â Â Â u[x] = y
Â Â Â Â Â Â Â Â } else {
Â Â Â Â Â Â Â Â Â Â Â Â u[y] = x
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}

```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
Valid Sudokuï¼ˆæœ‰æ•ˆçš„æ•°ç‹¬ï¼‰goè¯­è¨€å®ç°

func isValidSudoku(board [][]byte) bool {

Â Â Â Â isValid:=true
Â Â Â Â for i:=0;i<9;i++{
Â Â Â Â Â Â Â Â for j:=0;j<9;j++{
Â Â Â Â Â Â Â Â Â Â Â Â if board[i][j]=='.' {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â Â Â Â Â }else{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if !judgeLine(board,i,j){
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â return isValid
}

func judgeLine(board [][]byte,i,j int) bool{
Â Â Â Â hash:=make(map[byte]int,9)
Â Â Â Â for k:=0;k<9;k++{
Â Â Â Â Â Â Â Â if board[i][k]!='.'{
Â Â Â Â Â Â Â Â Â Â Â Â if hash[board[i][k]]==0{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hash[board[i][k]]=1
Â Â Â Â Â Â Â Â Â Â Â Â }else{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â hash=make(map[byte]int,9)
Â Â Â Â for k:=0;k<9;k++{
Â Â Â Â Â Â Â Â if board[k][j]!='.' {
Â Â Â Â Â Â Â Â Â Â Â Â if hash[board[k][j]]==0{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hash[board[k][j]]=1
Â Â Â Â Â Â Â Â Â Â Â Â }else{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â hash=make(map[byte]int,9)
Â Â Â Â for m:=i/3*3;m<i/3*3+3;m++{
Â Â Â Â Â Â Â Â for n:=j/3*3;n<j/3*3+3;n++{
Â Â Â Â Â Â Â Â Â Â Â Â if board[m][n]!='.'{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if hash[board[m][n]]==0{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â hash[board[m][n]]=1
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }else{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â return true

}



```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
Number of Islandsï¼ˆå²›å±¿çš„ä¸ªæ•°ï¼‰goè¯­è¨€å®ç°ï¼Œäº²æµ‹é€šè¿‡ï¼š
func numIslands(grid [][]byte) int {

Â Â Â Â isSearch:=make([][]int,len(grid))
Â Â Â Â island:=0
Â Â Â Â for i:=0;i<len(isSearch);i++{
Â Â Â Â Â Â Â Â isSearch[i]=make([]int,len(grid[0]))
Â Â Â Â }
Â Â Â Â for i,line:=range grid{
Â Â Â Â Â Â Â Â for j,_:=range line{
Â Â Â Â Â Â Â Â Â Â Â Â if isSearch[i][j]==0 && grid[i][j]=='1'{
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Search(grid,isSearch,i,j)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â island++
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â return island
}

func Search(grid [][]byte,isSearch [][]int, i int,j int){
Â Â Â Â if isSearch[i][j]==1{
Â Â Â Â Â Â Â Â return
Â Â Â Â }
Â Â Â Â isSearch[i][j]=1
Â Â Â Â if grid[i][j]=='1'{
Â Â Â Â Â Â Â Â if i>=1{
Â Â Â Â Â Â Â Â Â Â Â Â Search(grid,isSearch,i-1,j)
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if i<len(grid)-1{
Â Â Â Â Â Â Â Â Â Â Â Â Search(grid,isSearch,i+1,j)
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if j>=1{
Â Â Â Â Â Â Â Â Â Â Â Â Search(grid,isSearch,i,j-1)
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if j<len(grid[0])-1{
Â Â Â Â Â Â Â Â Â Â Â Â Search(grid,isSearch,i,j+1)
Â Â Â Â Â Â Â Â }
Â Â Â Â }else{
Â Â Â Â Â Â Â Â return
Â Â Â Â }
}

```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
    å²›å±¿æ•°Javaå®ç°
public int numIslands(char[][] grid) {
Â Â Â Â Â Â Â Â int m = grid.length;
Â Â Â Â Â Â Â Â if (m == 0) return 0;
Â Â Â Â Â Â Â Â int n = grid[0].length;
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â int ans = 0;
Â Â Â Â Â Â Â Â for (int y = 0; y < m; ++y)
Â Â Â Â Â Â Â Â Â Â Â Â for (int x = 0; x < n; ++x)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (grid[y][x] == '1') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ++ans;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â dfs(grid, x, y, n, m);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return ans;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â private void dfs(char[][] grid, int x, int y, int n, int m) {
Â Â Â Â Â Â Â Â if (x < 0 || y < 0 || x >= n || y >= m || grid[y][x] == '0')
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â grid[y][x] = '0';
Â Â Â Â Â Â Â Â dfs(grid, x + 1, y, n, m);
Â Â Â Â Â Â Â Â dfs(grid, x - 1, y, n, m);
Â Â Â Â Â Â Â Â dfs(grid, x, y + 1, n, m);
Â Â Â Â Â Â Â Â dfs(grid, x, y - 1, n, m);
Â Â Â Â }
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
å·²ç»åˆå…­å•¦ï¼Œå°±å¿«è¦åˆ°å»å­¦æ ¡çš„æ—¶é—´äº†ï¼Œéš¾å—ã€‚
å›¾çš„é‚»æ¥çŸ©é˜µè¡¨ç¤ºæ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„int[0..n-1][0...n-1]æ¥ä¿å­˜é¡¶ç‚¹å’Œè¾¹çš„ï¼Œå¯¹äºæ— æƒå›¾ï¼Œ1è¡¨ç¤ºæœ‰è¾¹ï¼Œ0è¡¨ç¤ºä¸¤ä¸ªé¡¶ç‚¹æ²¡æœ‰å˜ï¼Œæœ‰æƒå›¾ï¼Œå€¼ä»£è¡¨æƒé‡ã€‚
å›¾çš„é‚»æ¥è¡¨åˆ™æ˜¯é‡‡ç”¨æ•°ç»„+é“¾è¡¨çš„ç»“æ„æ¥è¡¨ç¤ºçš„ï¼Œæ•°ç»„é‡Œå­˜çš„æ˜¯é¡¶ç‚¹ï¼Œé“¾è¡¨å­˜å‚¨çš„æ˜¯è¾¹çš„ä¿¡æ¯ï¼Œå½“ç„¶é“¾è¡¨ä¹Ÿå¯ä»¥æ¢åšäºŒå‰æœç´¢æ ‘ï¼Œæ•£åˆ—è¡¨ç­‰é«˜æ•ˆæŸ¥æ‰¾çš„æ•°æ®ç»“æ„ã€‚
ä»Šå¤©çš„ä¸¤é“leetcodeé¢˜çš„è§£é¢˜æ€è·¯å’Œä»£ç å¦‚ä¸‹ï¼š
1.Â Â Â Â Number of Islands ï¼ˆå²›å±¿çš„ä¸ªæ•°ï¼‰
è§£é¢˜æ€è·¯ï¼šéå†æ•°ç»„ï¼Œé‡åˆ°1æ—¶ï¼Œä½¿ç”¨æ·±åº¦/å¹¿åº¦éå†ï¼Œå°†è¿é€šçš„1éƒ½ç½®ä¸º0ï¼Œç„¶åå°†å²›å±¿ä¸ªæ•°åŠ 1.
ä»£ç ï¼šhttps://github.com/yyxd/leetcode/blob/master/src/leetcode/graph/Problem200_NumberofIslands.java
2.Â Â Â Â Valid Sudoku Â ï¼ˆæœ‰æ•ˆçš„æ•°ç‹¬ï¼‰
è§£é¢˜æ€è·¯ï¼šemmï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™é“é¢˜è¦æ”¾åœ¨å›¾è®ºçš„ä¸“é¢˜ä¸‹ï¼Œæˆ‘çš„è§£æ³•å°±æ˜¯æ¨ªç€ä¸€è¡Œè¡Œåˆ¤æ–­ï¼Œç«–ç€ä¸€åˆ—åˆ—çš„åˆ¤æ–­ï¼Œç„¶åæ¯ä¸ª3*3çš„å­å—è¿›è¡Œåˆ¤æ–­ã€‚æ²¡æœ‰ç”¨åˆ°å›¾çš„çŸ¥è¯†ã€‚
ä»£ç ï¼šhttps://github.com/yyxd/leetcode/blob/master/src/leetcode/graph/Problem36_ValidSudoku.java

```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
åŸºäºä¸´æ¥è¡¨å®ç°çš„è”é€šåˆ†é‡æ±‚æ³•ï¼Œ go è¯­è¨€å®ç°ï¼š
package graph_basics

type Components struct {
Â Â Â Â graph   Graph
Â Â Â Â visited []bool
Â Â Â Â id      []int
Â Â Â Â ccount  int
}

func InitComponents(g Graph) *Components {
Â Â Â Â return &Components{
Â Â Â Â Â Â Â Â graph:   g,
Â Â Â Â Â Â Â Â visited: make([]bool, g.V()),
Â Â Â Â Â Â Â Â id:      make([]int, g.V()),
Â Â Â Â Â Â Â Â ccount:  0,
Â Â Â Â }
}

func (c *Components) dfs(index int) {
Â Â Â Â c.visited[index] = true
Â Â Â Â c.id[index] = c.ccount
Â Â Â Â adj := c.graph.Iterator(index)
Â Â Â Â for i := range adj {
Â Â Â Â Â Â Â Â if !c.visited[adj[i]] {
Â Â Â Â Â Â Â Â Â Â Â Â c.dfs(adj[i])
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}

func (c *Components) CalculateComponents() {
Â Â Â Â for i := 0; i < c.graph.V(); i++ {
Â Â Â Â Â Â Â Â if c.visited[i] {
Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â c.dfs(i)
Â Â Â Â Â Â Â Â c.ccount++
Â Â Â Â }
}

func (c *Components) Count() int {
Â Â Â Â return c.ccount
}

func (c *Components) IsConnected(p int, q int) bool {
Â Â Â Â return c.id[p] == c.id[q]
}

ä¸´æ¥è¡¨çš„å®ç°ï¼š
package graph_basics

import &#34;fmt&#34;

type SparseGraph struct {
Â Â Â Â v      int
Â Â Â Â e      int
Â Â Â Â direct bool
Â Â Â Â g      [][]int
}

func InitSparseGraph(n int, direct bool) *SparseGraph {
Â Â Â Â graph := make([][]int, n)
Â Â Â Â return &SparseGraph{
Â Â Â Â Â Â Â Â v:      n,
Â Â Â Â Â Â Â Â e:      0,
Â Â Â Â Â Â Â Â direct: direct,
Â Â Â Â Â Â Â Â g:      graph,
Â Â Â Â }
}

func (sg *SparseGraph) V() int {
Â Â Â Â return sg.v
}

func (sg *SparseGraph) E() int {
Â Â Â Â return sg.e
}

func (sg *SparseGraph) AddEdge(p int, q int) {
Â Â Â Â sg.g[p] = append(sg.g[p], q)
Â Â Â Â if !sg.direct {
Â Â Â Â Â Â Â Â sg.g[q] = append(sg.g[q], p)
Â Â Â Â }

Â Â Â Â sg.e++
}

func (sg *SparseGraph) HasEdge(p int, q int) bool {
Â Â Â Â for i := 0; i < len(sg.g[p]); i++ {
Â Â Â Â Â Â Â Â if sg.g[p][i] == q {
Â Â Â Â Â Â Â Â Â Â Â Â return true
Â Â Â Â Â Â Â Â }
Â Â Â Â }
Â Â Â Â return false
}

func (sg *SparseGraph) Show() {
Â Â Â Â for i := range sg.g {
Â Â Â Â Â Â Â Â fmt.Printf(&#34;vertex %d :\t&#34;, i)
Â Â Â Â Â Â Â Â for j := range sg.g[i] {
Â Â Â Â Â Â Â Â Â Â Â Â fmt.Printf(&#34;%d\t&#34;, sg.g[i][j])
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â fmt.Println()
Â Â Â Â }
}

func (sg *SparseGraph) Iterator(v int) []int {
Â Â Â Â return sg.g[v]
}
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
å²›å±¿ä¸ªæ•°pythonå®ç°(å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•)ï¼š
def numIslands(self, grid):
Â Â Â Â if not grid:
Â Â Â Â Â Â Â Â return 0
Â Â Â Â Â Â Â Â 
Â Â Â Â count = 0
Â Â Â Â for i in range(len(grid)):
Â Â Â Â Â Â Â Â for j in range(len(grid[0])):
Â Â Â Â Â Â Â Â Â Â Â Â if grid[i][j] == '1':
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self.dfs(grid, i, j)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â count += 1
Â Â Â Â return count

def dfs(self, grid, i, j):
Â Â Â Â if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
Â Â Â Â Â Â Â Â return
Â Â Â Â grid[i][j] = '#'
Â Â Â Â self.dfs(grid, i+1, j)
Â Â Â Â self.dfs(grid, i-1, j)
Â Â Â Â self.dfs(grid, i, j+1)
Â Â Â Â self.dfs(grid, i, j-1)
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
æœ‰æ•ˆçš„æ•°ç‹¬ go è¯­è¨€å®ç°
package main

import (
Â Â Â Â &#34;fmt&#34;
)

func hasRepeatedNumbers(numbers []byte) bool {
Â Â Â Â var numbersExistFlag [9]bool
Â Â Â Â for _, num := range numbers {
Â Â Â Â Â Â Â Â if num == '.' {
Â Â Â Â Â Â Â Â Â Â Â Â continue
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â index := num - '0' - 1
Â Â Â Â Â Â Â Â if numbersExistFlag[index] {
Â Â Â Â Â Â Â Â Â Â Â Â return true
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â numbersExistFlag[index] = true
Â Â Â Â }
Â Â Â Â return false
}

func isValidSudoku(board [][]byte) bool {
Â Â Â Â sudokuSize := 9
Â Â Â Â sudokuUnitSize := 3
Â Â Â Â for _, line := range board {
Â Â Â Â Â Â Â Â if hasRepeatedNumbers(line) {
Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â for columnIndex := 0; columnIndex < sudokuSize; columnIndex++ {
Â Â Â Â Â Â Â Â columnNumbers := make([]byte, 0)
Â Â Â Â Â Â Â Â for lineIndex := 0; lineIndex < sudokuSize; lineIndex++ {
Â Â Â Â Â Â Â Â Â Â Â Â columnNumbers = append(columnNumbers, board[lineIndex][columnIndex])
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if hasRepeatedNumbers(columnNumbers) {
Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â sudokuUnitCountEachLine := sudokuSize / sudokuUnitSize
Â Â Â Â for i := 0; i < sudokuUnitCountEachLine; i++ {
Â Â Â Â Â Â Â Â for j := 0; j < sudokuUnitCountEachLine; j++ {
Â Â Â Â Â Â Â Â Â Â Â Â sudokuUnitNumbers := make([]byte, 0)
Â Â Â Â Â Â Â Â Â Â Â Â for _, line := range board[i*3 : (i+1)*3] {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â sudokuUnitNumbers = append(sudokuUnitNumbers, line[j*3:(j+1)*3]...)
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â if hasRepeatedNumbers(sudokuUnitNumbers) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return false
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â return true
}

func main() {
Â Â Â Â testData1 := [][]byte{
Â Â Â Â Â Â Â Â {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
Â Â Â Â Â Â Â Â {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
Â Â Â Â Â Â Â Â {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
Â Â Â Â Â Â Â Â {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
Â Â Â Â Â Â Â Â {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
Â Â Â Â Â Â Â Â {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
Â Â Â Â Â Â Â Â {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
Â Â Â Â Â Â Â Â {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
Â Â Â Â Â Â Â Â {'.', '.', '.', '.', '8', '.', '.', '7', '9'}}
Â Â Â Â fmt.Println(isValidSudoku(testData1))
}
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
1.åœ¨é‚»æ¥çŸ©é˜µä¸­æ‰¾å‡ºè¿é€šå›¾ä¸ªæ•°å³å¯ã€‚åœ¨æ¯ä¸ªé¡¶ç‚¹æ‰§è¡ŒDFSæˆ–BFSï¼Œæ‰§è¡Œæ¬¡æ•°å³ä¸ºå²›å±¿æ•°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¹¶æŸ¥é›†ã€‚

2. ä¾æ¬¡è€ƒå¯Ÿ9âœ–ï¸9æ•°ç‹¬å„è¡Œå„åˆ—æ˜¯å¦æœ‰é‡å¤æ•°å­—ï¼ˆå¯ä»¥ç”¨9ä½æ•°ç»„ç»Ÿè®¡ï¼‰ï¼Œç„¶åå†è€ƒå¯Ÿæ¯ä¸ª3âœ–ï¸3å­çŸ©é˜µæ˜¯å¦æœ‰é‡å¤æ•°å­—ã€‚éƒ½æ²¡æœ‰åˆ™æˆåŠŸã€‚
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
islandä¸ªæ•°ï¼Œä»ä¸€ä¸ªç‚¹ä»å‘ï¼Œåˆ¤æ–­ä¸€ä¸ªislandçš„é€»è¾‘æ˜¯å¦‚æœæœ¬èº«ç‚¹æ˜¯waterï¼Œé‚£ä¹ˆå¿…ç„¶ä¸æ˜¯islandï¼Œå¦‚æœæ˜¯é™†åœ°ï¼Œè¯´æ˜å®ƒèƒ½æ‰©å±•æˆä¸€ä¸ªislandï¼Œé‚£ä¹ˆå‘ä¸Šä¸‹å·¦å³è¿›è¡Œæ‰©å±•ï¼Œç„¶åå†ä»¥æ‰©å±•çš„é™†åœ°ç‚¹åˆä¸€ç›´é€’å½’æ‰©å±•ï¼Œç›´åˆ°æ‰€æœ‰è¾¹ç•Œä¸º0ã€‚è€Œåˆ¤æ–­islandçš„ä¸ªæ•°ï¼Œå°±åœ¨æ­¤åŸºç¡€ä¸Šå»éå†æ‰€æœ‰ç‚¹ï¼Œå¹¶åŠ ä¸Šä¸€ä¸ªboolean[][]è®°å½•æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»è¢«éå†æˆ–è€…æ‰©å±•è¿‡ã€‚
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
Valid Sudoku

class Solution {
Â Â Â Â public boolean isValidSudoku(char[][] board) {
Â Â Â Â Â Â Â Â for (int row = 0; row < 9; row++) {
Â Â Â Â Â Â Â Â Â Â Â Â for (int col = 0; col < 9; col++) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (board[row][col] == '.') continue;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (!isValid(board, row, col)) return false;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return true;
Â Â Â Â }
Â Â Â Â 
Â Â Â Â private boolean isValid(char[][] board, final int row, final int col){
Â Â Â Â Â Â Â Â char target=board[row][col];
Â Â Â Â Â Â Â Â //check rows
Â Â Â Â Â Â Â Â for (int i = 0; i < 9; i++) {
Â Â Â Â Â Â Â Â Â Â Â Â if (i == row) continue;
Â Â Â Â Â Â Â Â Â Â Â Â if (board[i][col] == target) return false;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â //check cols
Â Â Â Â Â Â Â Â for (int i = 0; i < 9; i++) {
Â Â Â Â Â Â Â Â Â Â Â Â if (i == col) continue;
Â Â Â Â Â Â Â Â Â Â Â Â if (board[row][i] == target) return false;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â //check 3*3
Â Â Â Â Â Â Â Â int rowStart = row / 3 * 3, colStart = col / 3 * 3;
Â Â Â Â Â Â Â Â for (int i = rowStart; i < rowStart + 3; i++) {
Â Â Â Â Â Â Â Â Â Â Â Â for (int j = colStart; j < colStart + 3; j++) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (i == row && j == col) continue;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (board[i][j] == target) return false;
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â return true;
Â Â Â Â }
}
```
 ----- 
<a style='font-size:1.5em;font-weight:bold'></a> 


 ```java 
æœ‰æ•ˆçš„æ•°ç‹¬
class Solution {
Â Â public:
Â Â Â Â bool isValidSudoku(vector< vector<char> >& board) {
Â Â Â Â Â Â set<char> numset;
Â Â Â Â Â Â for (int i = 0; i < 9; i++) {
Â Â Â Â Â Â Â Â numset.clear();
Â Â Â Â Â Â Â Â for (int j = 0; j < 9; j++) {
Â Â Â Â Â Â Â Â Â Â char val = board[i][j];
Â Â Â Â Â Â Â Â Â Â if (val != '.') {
Â Â Â Â Â Â Â Â Â Â Â Â if (numset.count(val) != 0) return false;
Â Â Â Â Â Â Â Â Â Â Â Â numset.insert(val);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â Â Â for (int j = 0; j < 9; j++) {
Â Â Â Â Â Â Â Â numset.clear();
Â Â Â Â Â Â Â Â for (int i = 0; i < 9; i++) {
Â Â Â Â Â Â Â Â Â Â char val = board[i][j];
Â Â Â Â Â Â Â Â Â Â if (val != '.') {
Â Â Â Â Â Â Â Â Â Â Â Â if (numset.count(val) != 0) return false;
Â Â Â Â Â Â Â Â Â Â Â Â numset.insert(val);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â Â Â for (int i = 0; i < 3; i++) {
Â Â Â Â Â Â Â Â for (int j = 0; j < 3; j++) {
Â Â Â Â Â Â Â Â Â Â numset.clear();
Â Â Â Â Â Â Â Â Â Â for (int p = 0; p < 3; p++) {
Â Â Â Â Â Â Â Â Â Â Â Â for (int q = 0; q < 3; q++) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â char val = board[i * 3 + p][j * 3 + q];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (val != '.') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if (numset.count(val) != 0) return false;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â numset.insert(val);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â Â Â return true;
Â Â Â Â }
};
```
 ----- 
:::