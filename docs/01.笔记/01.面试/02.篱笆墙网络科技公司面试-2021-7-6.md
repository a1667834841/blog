---
title: 篱笆墙网络科技公司面试-2021-7-6
date: 2021-12-06 17:01:28
permalink: /pages/0f0bde/
categories:
  - 笔记
  - 面试
tags:
  - 
---
## Java中如何保证线程安全性
 
什么是线程安全：
当多个线程访问某个方法时，不管你通过怎样的调用方式、或者说这些线程如何交替地执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类是线程安全的。  
 
 


### 1.首先说明并发编程的三个特性
原子性
可见性
有序性
### 2.在说明保证并发编程安全的方法
 
**1.使用atomic类**
底层借助了UnSafe类提供的CAS操作能够保证数据更新的时候是线程安全的
解释CAS
**组成：**
CAS操作包括三个操作数：需要读写的内存位置(V)、预期原值(A)、新值(B)。如果内存位置与预期原值的A相匹配，那么将内存位置的值更新为新值B。如果内存位置与预期原值的值不匹配，那么处理器不会做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。
 
**运行原理：**
冲突检测和数据更新。当多个线程尝试使用CAS同时更新同一个变量时，只有一个线程可以更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是告知这次竞争中失败了，并可以再次尝试。
2.加锁synchronized和lock
 
3.在变量上加final关键字
 
 
 
## 拦截器与过滤器的区别 ：
 
1.过滤器：
依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等
2.拦截器：
依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上基于[Java](https://link.jianshu.com?t=http%3A%2F%2Fwww.07net01.com%2Ftags-Java-0.html)的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理
 
**总结：**
 
1. 拦截器是基于java的反射机制的，而过滤器是基于函数回调。
2. 拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
3. 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
4. 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
5. 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次
 
## 解决分布式集群环境下定时任务执行多次
 
 
问题：由于我们项目同时部署在多台集群机器上，因此到达指定的定时时间时，多台机器上的定时器可能会同时启动，造成重复数据或者程序异常等问题，
 
**借助Redis的过期机制和分布式锁**
 
解决方法：为你的定时器在Redis中定义一个键值对，可以用项目名称和服务器ip，执行任务前先从Redis中读取键，若没有值代表任务未被执行，同样的该台机器先更新redis，再触发定时任务。由于Redis存在过期机制，因此可以设置过期时间保证下次判断正常
 
优缺点：该方法个人比较推荐，简单，对业务逻辑的改变也会少很多，只需要在原来的定时器上加上简单判断即可
 
 
## redis存储热点数据思路？
用户点击商品，将商品点击数存入redis库中，再使用redis的淘汰策略
 
当redis使用的内存超过了设置的最大内存时，会触发redis的key淘汰机制，在redis 3.0中有6种淘汰策略：
 
noeviction: 不删除策略。当达到最大内存限制时, 如果需要使用更多内存,则直接返回错误信息。（redis默认淘汰策略）
allkeys-lru: 在所有key中优先删除最近最少使用(less recently used ,LRU) 的 key。
allkeys-random: 在所有key中随机删除一部分 key。
volatile-lru: 在设置了超时时间（expire ）的key中优先删除最近最少使用(less recently used ,LRU) 的 key。
volatile-random: 在设置了超时时间（expire）的key中随机删除一部分 key。
volatile-ttl: 在设置了超时时间（expire ）的key中优先删除剩余时间(time to live,TTL) 短的key。
 
 
 
 
 
 
 
 
 
 
 
