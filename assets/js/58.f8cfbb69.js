(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{523:function(a,t,v){"use strict";v.r(t);var e=v(20),_=Object(e.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"runtime-data-area-and-instruction-set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#runtime-data-area-and-instruction-set"}},[a._v("#")]),a._v(" Runtime Data Area and Instruction Set")]),a._v(" "),v("p",[a._v("jvms 2.4 2.5")]),a._v(" "),v("h2",{attrs:{id:"指令集分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#指令集分类"}},[a._v("#")]),a._v(" 指令集分类")]),a._v(" "),v("ol",[v("li",[a._v("基于寄存器的指令集")]),a._v(" "),v("li",[a._v("基于栈的指令集\nHotspot中的Local Variable Table = JVM中的寄存器")])]),a._v(" "),v("h2",{attrs:{id:"runtime-data-area"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#runtime-data-area"}},[a._v("#")]),a._v(" Runtime Data Area")]),a._v(" "),v("p",[a._v("PC 程序计数器")]),a._v(" "),v("blockquote",[v("p",[a._v("存放指令位置")]),a._v(" "),v("p",[a._v("虚拟机的运行，类似于这样的循环：")]),a._v(" "),v("p",[a._v("while( not end ) {")]),a._v(" "),v("p",[a._v("​\t取PC中的位置，找到对应位置的指令；")]),a._v(" "),v("p",[a._v("​\t执行该指令；")]),a._v(" "),v("p",[a._v("​\tPC ++;")]),a._v(" "),v("p",[a._v("}")])]),a._v(" "),v("p",[a._v("JVM Stack")]),a._v(" "),v("ol",[v("li",[a._v("Frame - 每个方法对应一个栈帧\n"),v("ol",[v("li",[a._v("Local Variable Table")]),a._v(" "),v("li",[a._v("Operand Stack\n对于long的处理（store and load），多数虚拟机的实现都是原子的\njls 17.7，没必要加volatile")]),a._v(" "),v("li",[a._v("Dynamic Linking\nhttps://blog.csdn.net/qq_41813060/article/details/88379473\njvms 2.6.3")]),a._v(" "),v("li",[a._v("return address\na() -> b()，方法a调用了方法b, b方法的返回值放在什么地方")])])])]),a._v(" "),v("p",[a._v("Heap")]),a._v(" "),v("p",[a._v("Method Area")]),a._v(" "),v("ol",[v("li",[a._v("Perm Space (<1.8)\n字符串常量位于PermSpace\nFGC不会清理\n大小启动的时候指定，不能变")]),a._v(" "),v("li",[a._v("Meta Space (>=1.8)\n字符串常量位于堆\n会触发FGC清理\n不设定的话，最大就是物理内存")])]),a._v(" "),v("p",[a._v("Runtime Constant Pool")]),a._v(" "),v("p",[a._v("Native Method Stack")]),a._v(" "),v("p",[a._v("Direct Memory")]),a._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/zxqzhuzhu/imgs/raw/master/image-20210405122311545.png",alt:"image-20210405122311545"}})]),a._v(" "),v("blockquote",[v("p",[a._v("JVM可以直接访问的内核空间的内存 (OS 管理的内存)")]),a._v(" "),v("p",[a._v("NIO ， 提高效率，实现zero copy")])]),a._v(" "),v("p",[a._v("思考：")]),a._v(" "),v("blockquote",[v("p",[a._v("如何证明1.7字符串常量位于Perm，而1.8位于Heap？")]),a._v(" "),v("p",[a._v("提示：结合GC， 一直创建字符串常量，观察堆，和Metaspace")])]),a._v(" "),v("h2",{attrs:{id:"常用指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用指令"}},[a._v("#")]),a._v(" 常用指令")]),a._v(" "),v("p",[v("cinit",[a._v(" 静态语句块初始化")])],1),a._v(" "),v("p",[v("init",[a._v(" 调用构造方法")])],1),a._v(" "),v("p",[a._v("store 弹栈操作")]),a._v(" "),v("p",[a._v("load 压栈操作")]),a._v(" "),v("p",[a._v("pop 将值弹到栈顶位置 （Pop the top value from the operand stack.）")]),a._v(" "),v("p",[a._v("mul")]),a._v(" "),v("p",[a._v("sub")]),a._v(" "),v("p",[a._v("invoke")]),a._v(" "),v("ol",[v("li",[a._v("InvokeStatic")]),a._v(" "),v("li",[a._v("InvokeVirtual")]),a._v(" "),v("li",[a._v("InvokeInterface")]),a._v(" "),v("li",[a._v("InovkeSpecial\n可以直接定位，不需要多态的方法\nprivate 方法 ， 构造方法")]),a._v(" "),v("li",[a._v("InvokeDynamic\nJVM最难的指令\nlambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令")])]),a._v(" "),v("p",[v("img",{attrs:{src:"D:%5Cproject%5Cvscode%5Cvuepress-theme-reco-demo%5Cmy-blog%5Cblogs%5C%E7%AC%94%E8%AE%B0%5Cjava%5Cjvm%5Cjava%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.assets%5Cimage-20210405151204316.png",alt:"image-20210405151204316"}})]),a._v(" "),v("p",[a._v("注意：非静态方法的局部变量表，首个局部变量是this")])])}),[],!1,null,null,null);t.default=_.exports}}]);