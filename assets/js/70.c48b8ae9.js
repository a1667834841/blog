(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{534:function(e,t,a){"use strict";a.r(t);var r=a(20),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"流与块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流与块"}},[e._v("#")]),e._v(" 流与块")]),e._v(" "),a("p",[e._v("I/O 与 NIO 最重要的区别是数据打包和传输的方式，"),a("strong",[e._v("I/O 以流的方式处理数据")]),e._v("，而 "),a("strong",[e._v("NIO 以块的方式处理数据")]),e._v("。 面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。")]),e._v(" "),a("h1",{attrs:{id:"nio-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nio-组件"}},[e._v("#")]),e._v(" nio 组件")]),e._v(" "),a("h2",{attrs:{id:"缓冲区buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓冲区buffer"}},[e._v("#")]),e._v(" 缓冲区Buffer")]),e._v(" "),a("p",[e._v("概念：Buffer是一个对象，它包含一些要写入或者要读出的数据。")]),e._v(" "),a("p",[e._v("使用途径：在NIO库中，所有数据都是用缓冲区处理的。")]),e._v(" "),a("p",[e._v("具体表现：缓冲区实质上是一个数组。通常它是一个字节数组（ByteBuffer），也可以使用其他种类的数组。最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基\n本类型（除了Boolean类型）都对应有一种缓冲区。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zxqzhuzhu/imgs/raw/master/picGo/image-20220106144000111.png",alt:"image-20220106144000111"}})]),e._v(" "),a("h2",{attrs:{id:"channel-管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#channel-管道"}},[e._v("#")]),e._v(" channel（管道）")]),e._v(" "),a("p",[e._v("概念：Channel是一个通道，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而通道可以用于读、写或者二者同时进行。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zxqzhuzhu/imgs/raw/master/picGo/image-20220106145149908.png",alt:"image-20220106145149908"}})]),e._v(" "),a("p",[e._v("从类图可以看出很乱，书上说Channel可以分为两大类：用于网络读写的SelectableChannel和用于文件操作的FileChannel。")]),e._v(" "),a("h2",{attrs:{id:"多路复用器selector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用器selector"}},[e._v("#")]),e._v(" 多路复用器Selector")]),e._v(" "),a("p",[e._v("作用：Selector会不断地轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。")]),e._v(" "),a("p",[e._v("优化：一个多路复用器Selector可以同时轮询多个Channel，由于JDK使用了"),a("code",[e._v("epoll（）")]),e._v("代替传统的"),a("code",[e._v("select")]),e._v("实现，所以它并没有最大连接句柄1024/2048的限制。这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端，这确实是个非常巨大的进步。")])])}),[],!1,null,null,null);t.default=n.exports}}]);