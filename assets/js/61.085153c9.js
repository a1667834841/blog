(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{523:function(e,o,n){"use strict";n.r(o);var r=n(20),t=Object(r.a)({},(function(){var e=this.$createElement,o=this._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[o("p",[this._v("Java-五种线程池，四种拒绝策略，三种阻塞队列(常用)")]),this._v(" "),o("p",[this._v("三种阻塞队列：\nBlockingQueue"),o("Runnable",[this._v(" workQueue = null;\nworkQueue = new ArrayBlockingQueue<>(5);//基于数组的先进先出队列，有界\nworkQueue = new LinkedBlockingQueue<>();//基于链表的先进先出队列，无界\nworkQueue = new SynchronousQueue<>();//无缓冲的等待队列，无界\n四种拒绝策略：\nRejectedExecutionHandler rejected = null;\nrejected = new ThreadPoolExecutor.AbortPolicy();//默认，队列满了丢任务抛出异常\nrejected = new ThreadPoolExecutor.DiscardPolicy();//队列满了丢任务不异常\nrejected = new ThreadPoolExecutor.DiscardOldestPolicy();//将最早进入队列的任务删，之后再尝试加入队列\nrejected = new ThreadPoolExecutor.CallerRunsPolicy();//如果添加到线程池失败，那么主线程会自己去执行该任务\n五种线程池：\nExecutorService threadPool = null;\nthreadPool = Executors.newCachedThreadPool();//有缓冲的线程池，线程数 JVM 控制\nthreadPool = Executors.newFixedThreadPool(3);//固定大小的线程池\nthreadPool = Executors.newScheduledThreadPool(2);\nthreadPool = Executors.newSingleThreadExecutor();//单线程的线程池，只有一个线程在工作\nthreadPool = new ThreadPoolExecutor();//默认线程池，可控制参数比较多")])],1)])}),[],!1,null,null,null);o.default=t.exports}}]);