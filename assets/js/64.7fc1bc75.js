(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{528:function(t,a,v){"use strict";v.r(a);var s=v(20),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"什么是jmm模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是jmm模型"}},[t._v("#")]),t._v(" 什么是JMM模型")]),t._v(" "),v("blockquote",[v("p",[t._v("JMM是一组抽象的概念，并不真实存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段 和构成数组对象的元素）的访问方式。"),v("strong",[t._v("JMM是围绕原子性，有序性、可见性展开的")])])]),t._v(" "),v("p",[t._v("工作内存和主内存交互图（1-1）")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/zxqzhuzhu/imgs/raw/master/image-20210325215632833.png",alt:"image-20210325215632833"}})]),t._v(" "),v("h2",{attrs:{id:"主内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主内存"}},[t._v("#")]),t._v(" 主内存")]),t._v(" "),v("p",[t._v("主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该"),v("strong",[t._v("实例")]),t._v(" "),v("strong",[t._v("对象是成员变量还是方法中的本地变量(也称局部变量)")]),t._v("，当然也包括了共享的类信息、常 量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。")]),t._v(" "),v("h2",{attrs:{id:"工作内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作内存"}},[t._v("#")]),t._v(" 工作内存")]),t._v(" "),v("p",[v("strong",[t._v("主要存储当前方法的所有本地变量信息")]),t._v("(工作内存中存储着主内存中的变量副本拷贝)， "),v("strong",[t._v("每个线程")]),t._v("只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安 全问题。")]),t._v(" "),v("h1",{attrs:{id:"主内存和工作内存是如何交互的-了解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主内存和工作内存是如何交互的-了解"}},[t._v("#")]),t._v(" 主内存和工作内存是如何交互的（了解）")]),t._v(" "),v("p",[t._v("首先Java内存模型定义了以下八种操作，来进行主内存和工作内存交互")]),t._v(" "),v("p",[t._v("（1）"),v("strong",[t._v("lock(锁定)")]),t._v("：作用于主内存的变量，把一个变量标记为一条线程独占状态")]),t._v(" "),v("p",[t._v("（2）"),v("strong",[t._v("unlock(解锁)")]),t._v("：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后")]),t._v(" "),v("p",[t._v("的变量才可以被其他线程锁定")]),t._v(" "),v("p",[t._v("（3）"),v("strong",[t._v("read(读取)")]),t._v("：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存")]),t._v(" "),v("p",[t._v("中，以便随后的load动作使用")]),t._v(" "),v("p",[t._v("（4）"),v("strong",[t._v("load(载入)")]),t._v("：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工")]),t._v(" "),v("p",[t._v("作内存的变量副本中")]),t._v(" "),v("p",[t._v("（5）"),v("strong",[t._v("use(使用)")]),t._v("：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎")]),t._v(" "),v("p",[t._v("（6）"),v("strong",[t._v("assign(赋值)")]),t._v("：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内")]),t._v(" "),v("p",[t._v("存的变量")]),t._v(" "),v("p",[t._v("（7）"),v("strong",[t._v("store(存储)")]),t._v("：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存")]),t._v(" "),v("p",[t._v("中，以便随后的write的操作")]),t._v(" "),v("p",[t._v("（8）"),v("strong",[t._v("write(写入)")]),t._v("：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值")]),t._v(" "),v("p",[t._v("传送到主内存的变量中")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/zxqzhuzhu/imgs/raw/master/image-20210325220707427.png",alt:"image-20210325220707427"}})]),t._v(" "),v("blockquote",[v("p",[t._v("这里如果是多线程的话，就会引起并发的问题了")])]),t._v(" "),v("p",[v("img",{attrs:{src:"D:%5Cproject%5Cvscode%5Cvuepress-theme-reco-demo%5Cmy-blog%5Cblogs%5C%E7%AC%94%E8%AE%B0%5Cjava%5C%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Cjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM.assets%5Cimage-20210325215632833.png",alt:"image-20210325215632833"}})]),t._v(" "),v("p",[t._v("图1-1中所示是 个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有 个所有 CPU 共享二级缓存。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 或者 L2 存或者 CPU 寄存器。当一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，然后对工作内存里的变量进行处理，处理完后将变量值更新到主内存。")]),t._v(" "),v("p",[t._v("那么假如线程A和线程B同时处理一个共享变量，会出现什么情况？我们使用图1-1所示CPU架构，假设线程A和线程B使用不同CPU执行，并且当前两级 Cache都为空，那么这时候由于 Cache的存在，将会导致内存不可见问题，具体看下面的分析")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("线程A首先获取共享变量X的值，由于两级 Cache都没有命中，所以加载主内存中X的值，假如为0.然后把X=0的值缓存到两级缓存，线程A修改X的值为1,然后将其写入两级 Cache，并且刷新到主内存。\n\n线程A操作完毕后，线程A所在的CPU的两级 Cache内和主内存里面的X的值都是线程B获取X的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了所以返回X=1;到这里一切都是正常的，因为这时候主内存中也是X=1.然后线程B修改X的值为2,并将其存放到线程2所在的一级 Cache和共享二级 Cache中最后更新主内存中X的值为2;\n\n到这里一切都是好的。线程A这次又需要修改X的值，获取时一级缓存命中，并且X-=1,到这里问题就出现了，明明线程B已经把X的值修改为了2,为何线程A获取的还是1呢？\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br")])]),v("blockquote",[v("p",[t._v("所以要谈到并发编程的三个特性 "),v("strong",[t._v("可见性，原子性，有序性")]),t._v("，解决了这三个问题并发问题也就引刃而解")])]),t._v(" "),v("h1",{attrs:{id:"并发编程的三个特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发编程的三个特性"}},[t._v("#")]),t._v(" 并发编程的三个特性")])])}),[],!1,null,null,null);a.default=_.exports}}]);