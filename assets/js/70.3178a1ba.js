(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{534:function(v,i,l){"use strict";l.r(i);var t=l(20),_=Object(t.a)({},(function(){var v=this,i=v.$createElement,l=v._self._c||i;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("Java1.4之前的早期版本，Java对I/O的支持并不完善，开发人员在开发高性能I/O程序的时候，会面临一些巨大的挑战和困难，主要问题如下:")]),v._v(" "),l("ul",[l("li",[v._v("没有数据缓冲区，I/O性能存在问题；")]),v._v(" "),l("li",[v._v("没有C或者C++中的Channel概念，只有输入和输出流；")]),v._v(" "),l("li",[v._v("同步阻塞式I/O通信（BIO），通常会导致通信线程被长时间阻塞；")]),v._v(" "),l("li",[v._v("支持的字符集有限，硬件可移植性不好。")])]),v._v(" "),l("blockquote",[l("p",[v._v("在Java支持异步I/O之前的很长一段时间里，高性能服务端开发领域一直被C++和C长期占据，Java的同步阻塞I/O被大家所诟病。")])]),v._v(" "),l("h2",{attrs:{id:"linux-io模型简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#linux-io模型简介"}},[v._v("#")]),v._v(" linux io模型简介")]),v._v(" "),l("p",[v._v("linux 的一切操作都是对文件的操作，对文件的读写操作都会调用linux内核的系统命令，返回一个"),l("code",[v._v("file descriptor")]),v._v("（fd,文件描述符）,而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。")]),v._v(" "),l("p",[v._v("根据UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型，分别如下：")]),v._v(" "),l("ul",[l("li",[v._v("io阻塞模型")]),v._v(" "),l("li",[v._v("非阻塞io模型")]),v._v(" "),l("li",[v._v("io复用模型")]),v._v(" "),l("li",[v._v("信号驱动io模型")]),v._v(" "),l("li",[v._v("异步io模型")])])])}),[],!1,null,null,null);i.default=_.exports}}]);